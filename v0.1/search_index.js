var documenterSearchIndex = {"docs":
[{"location":"methods/#Methods-1","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"methods/#","page":"Methods","title":"Methods","text":"n_phases\nrates","category":"page"},{"location":"methods/#DiscretisedFluidQueues.n_phases","page":"Methods","title":"DiscretisedFluidQueues.n_phases","text":"n_phases(S::PhaseSet)\n\nReturn the number of phases from a PhaseSet, FluidQueue, or DiscretisedFluidQueue\n\n\n\n\n\n","category":"function"},{"location":"methods/#DiscretisedFluidQueues.rates","page":"Methods","title":"DiscretisedFluidQueues.rates","text":"rates(S::PhaseSet, i::Int)\n\nReturn the rate of the phase from a PhaseSet, FluidQueue, or DiscretisedFluidQueue\n\n\n\n\n\n","category":"function"},{"location":"#DiscretisedFluidQueues-1","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"","category":"section"},{"location":"#Numerical-approximation-schemes-for-stochastic-fluid-queues.-1","page":"DiscretisedFluidQueues","title":"Numerical approximation schemes for stochastic fluid queues.","text":"","category":"section"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"The evolution of a stochastic fluid queue with generator T_ij_ijin S and associated diagonal matrix of rates C = diag(c_iiin S) can be described by the PDE (when it exists)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"cfracpartialpartial t  mathbf f(xit) =  mathbf f(xit) T - cfracpartialpartial x  mathbf f(xit) C","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"where mathbf f(xit) dx = (f(xit))_iin S = (P(X(t)in dx varphi(t)=i))_iin S the time-dependent joint density/mass function. ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"This package implements finite element and finite volume numerical solvers to approximate the right-hand side of this PDE; ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Discontinuous Galerkin: projects the right-hand side of the PDE on to a basis of polynomials,\nFinite volume:\nQBD-RAP approximation: use matrix-exponential distributions to model the solution locally on each cell.","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"","category":"page"},{"location":"#Usage-1","page":"DiscretisedFluidQueues","title":"Usage","text":"","category":"section"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"pkg> add https://github.com/angus-lewis/DiscretisedFluidQueues","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"julia> using DiscretisedFluidQueues","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Create a model with (for example)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"T = [-2.5 2 0.5; 1 -2 1; 1 2 -3] # generator of the phase\nC = [0.0; 2.0; -3.0]    # rates dX/dt\n\nS = PhaseSet(C) \n\nmodel = FluidQueue(T,S) ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Create a discretisation mesh (a grid + method with which to approximate the solution) with any of (e.g.)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"nbases = 3\nmesh = DGMesh(nodes,nbases)\n\nfv_order = 3\nfvmesh = FVMesh(nodes,fv_order)\n\norder = 3\nfrapmesh = FRAPMesh(nodes,order)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Combine the model and the discretisation scheme (mesh) to form a discretised fluid queue","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"dq = DiscretisedFluidQueue(model,mesh)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Construct an approximation to the generator with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"B = build_full_generator(dq)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"B is essentially a matrix which we can think of as describing the ODE \\begin{equation}     \\frac{\\partial}{\\partial t}   \\mathbf a(t) =   \\mathbf a(t) B \\end{equation} where $ \\mathbf a(t)$ is a row vector of coefficients and $  \\mathbf a(t)  \\mathbf u(x,i) \\approx  \\mathbf f(x,i,t)$ approximates the solution where $ \\mathbf u(x,i)$ is a column vector of functions defined by the discretisation scheme.","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Construct an initial distribution with (e.g.)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"f(x,i) = (i-1)/12.0./sum(1:3) # the initial distribution\nd = SFMDistribution(f,dq)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Integrate over time with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"t = 3.2\ndt = integrate_time(d,B,t)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Reconstruct approximate solution with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"u = cdf(d)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Evaluate solution as a function ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"u(0.1,1) # = P(X(3.2)<0.1, phi(3.2)=1)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"More examples and documentation to come. ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"This is my PhD topic. I'll provide a link to a write up when I've done one...","category":"page"},{"location":"types/#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"Modules = [DiscretisedFluidQueues]\nOrder   = [:type]","category":"page"},{"location":"types/#DiscretisedFluidQueues.ConcentratedMatrixExponential","page":"Types","title":"DiscretisedFluidQueues.ConcentratedMatrixExponential","text":"Similar to MatrixExponential but has a neater implementation of orbit() due to nice structure.\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.DGMesh","page":"Types","title":"DiscretisedFluidQueues.DGMesh","text":"DGMesh <: Mesh\n\nA structure representing a discretisation scheme to be used for a DiscretisedFluidQueue. \n\nArguments:\n\nnodes::Array{<:Real, 1}: The edges of the cells.\nn_bases::Int: The number of basis functions used to represent the solution on each cell\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.DiscretisedFluidQueue","page":"Types","title":"DiscretisedFluidQueues.DiscretisedFluidQueue","text":"DiscretisedFluidQueue{T <: Mesh}\n\nA container to hold a FluidQueue and a discretisation scheme (a mesh).  Parametric type depending on the type of discretisation scheme (<:Mesh)\n\nArguments:\n\nmodel::Model: a FluidQueue\nmesh::T: either a DGMesh, FVMesh or FRAPMesh specifying the discretisation scheme for the    continuous level of the fluid queue, X(t). \n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.Euler","page":"Types","title":"DiscretisedFluidQueues.Euler","text":"Euler <: TimeIntegrationScheme\n\nDefines an Euler integration scheme to be used in integrate_time.\n\nArguments\n\nstep_size::Float64: the step size of the integration scheme.\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.FRAPMesh","page":"Types","title":"DiscretisedFluidQueues.FRAPMesh","text":"FRAPMesh <: Mesh\n\nA QBD-RAP (FRAM) discretisation scheme for a DiscretisedFluidQueue. \n\nArguments\n\nnodes: the cell edges\nme: the MatrixExponential used to approximate model the fluid queue on each cell.\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.FVMesh","page":"Types","title":"DiscretisedFluidQueues.FVMesh","text":"FVMesh <: Mesh\n\nA finite volume discretisation scheme for a DiscretisedFluidQueue. \n\nArguments\n\nnodes: the cell edges (the nodes are at the center of the cell)\norder: the order of the polynomial interpolation used to approximate the flux at the \n\ncell edges.\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.FluidQueue","page":"Types","title":"DiscretisedFluidQueues.FluidQueue","text":"FluidQueue <: Model\n\nConstructor for a fluid queue model.\n\nArguments:\n\nT::Array{<:Real, 2}: Generator of the phase process\nS::PhaseSet: An array of phases describing the evolution of the fluid level in each phase.\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.FullGenerator","page":"Types","title":"DiscretisedFluidQueues.FullGenerator","text":"FullGenerator <: Generator\n\nAn Matrix or SparseMatrixCSC representation of the generator of a generator of a DiscretisedFluidQueue.\n\nHigher memory requirements than LazyGenerator (as blocks are duplicated) but much faster matrix arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.Generator","page":"Types","title":"DiscretisedFluidQueues.Generator","text":"Generator\n\nAbstract type representing a discretised infinitesimal generator of a FLuidQueue.\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.LazyGenerator","page":"Types","title":"DiscretisedFluidQueues.LazyGenerator","text":"LazyGenerator <: Generator\n\nA lazy representation of a block matrix with is a generator of a DiscretisedFluidQueue.\n\nLower memory requirements than FullGenerator but aritmetic operations and indexing may be slower.\n\nArguments:\n\ndq::DiscretisedFluidQueue: \nblocks::Tuple{Array{Float64, 2}, Array{Float64, 2}, Array{Float64, 2}, Array{Float64, 2}}:    Block matrices describing the flow of mass within and between cells. blocks[1] is the lower    diagonal block describing the flow of mass from cell k+1 to cell (k for phases    with negative rate only). blocks[2] (blocks[3]) is the    diagonal block describing the flow of mass within a cell for a phase with positive (negative) rate.   blocks[4] is the upper diagonal block describing the flow of mass from cell k to k+1 (for phases    with positive rate only).  \nboundary_flux::BoundaryFluxTupleType: A named tuple structure such that        - boundary_flux.lower.in: describes flow of density into lower boundary       - boundary_flux.lower.out: describes flow of density out of lower boundary       - boundary_flux.upper.in: describes flow of density into upper boundary       - boundary_flux.upper.out: describes flow of density out of upper boundary\nD::Union{Array{Float64, 2}, LinearAlgebra.Diagonal{Bool, Array{Bool, 1}}}: An array describing    how the flow of density changes when the phase process jumps between phases with different memberships.   This is the identity for FV and DG schemes. \n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.MatrixExponential","page":"Types","title":"DiscretisedFluidQueues.MatrixExponential","text":"MatrixExponential constructor method\n\nMatrixExponential(\n    a::Array{Float64,2},\n    S::Array{Float64,2},\n    s::Array{Float64,1},\n    D::Array{Float64}=[0],\n)\n\nInputs: \n\na a 1 by p Array of reals\nS a p by p Array of reals\ns a p by 1 Array of reals\nD an optional argument, if empty then me.D is the identity,   else is a p by p matrix\n\nThrows an error if the dimensions are inconsistent.\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.Mesh","page":"Types","title":"DiscretisedFluidQueues.Mesh","text":"Mesh\n\nAbstract type representing a discretisation mesh for a numerical scheme. \n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.Model","page":"Types","title":"DiscretisedFluidQueues.Model","text":"Model\n\nAbstract type represnting a FluidQueue or DiscretisedFluidQueue\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.Phase","page":"Types","title":"DiscretisedFluidQueues.Phase","text":"Phase\n\nRepresents a phase of the fluid queue.\n\nArguments:\n\nc::Float64: the rate of change of the fluid X(t) associated with the phase\nm::Int64: either -1 or 1, membership of the phase with either the set of positive or negative phases.   Default is positive, i.e. 1. Only relevant for FRAPApproximation.\nlpm::Bool: whether the phase has a point mass at the left/lower boundary\nrpm::Bool: whether the phase has a point mass at the right/upper boundary\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.PhaseSet","page":"Types","title":"DiscretisedFluidQueues.PhaseSet","text":"const PhaseSet = Array{Phase,1}\n\nA container for phases.\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.PhaseSet-Tuple{Vector{Float64}, Vector{Int64}, BitArray, BitArray}","page":"Types","title":"DiscretisedFluidQueues.PhaseSet","text":"PhaseSet(c::Array{Float64, 1}[, m::Array{Int, 1}, lpm::BitArray, rpm::BitArray])\n\nConstruct an Array of phases.\n\nArguments:\n\nc: Array of rates\nm: (optional) array of memberships, see Phase()\nlpm: (optional) array of left point mass indicators, see Phase()\nrpm: (optional) array of right point mass indicators, see Phase()\n\n\n\n\n\n","category":"method"},{"location":"types/#DiscretisedFluidQueues.SFMDistribution","page":"Types","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution{T <: Mesh} <: AbstractArray{Float64, 2}\n\nRepresentation of the distribution of a DiscretisedFluidQueue. \n\nThe field coeffs is a row-vector and indexing a distribution indexes this field. Similarly,  arithmetic operations on a distribution act on this vector.\n\nArguments:\n\ncoeffs::Array{Float64, 2}: A row vector of coefficients which encode the distribution of a    DiscretisedFluidQueue and can be used to reconstruct a solution.\ndq::DiscretisedFluidQueue{T}: \n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.SFMDistribution","page":"Types","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution(pdf::Function, dq::DiscretisedFluidQueue{FVMesh}, fun_evals::Int = 6)\n\nConstruct an approximation to pdf as the average of pdf of each cell. \n\nUses quadrature with fun_evals function evaluations to approximate cell averages.\n\n\n\n\n\n","category":"type"},{"location":"types/#DiscretisedFluidQueues.SFMDistribution-Tuple{Function, DiscretisedFluidQueue{DGMesh}}","page":"Types","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution(pdf::Function, dq::DiscretisedFluidQueue{DGMesh})\n\nApproximates pdf via polynomials. \n\n\n\n\n\n","category":"method"},{"location":"types/#DiscretisedFluidQueues.SFMDistribution-Tuple{Function, DiscretisedFluidQueue{FRAPMesh}}","page":"Types","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution(pdf::Function, dq::DiscretisedFluidQueue{FRAPMesh}; fun_evals = 100)\n\nReturn the appropriate initial condition to approximate the initial distribution pdf for the numerical discretisation scheme defined by the dq DiscretisedFluidQueue.\n\ni.e. for each cell compute the expected orbit position  pdf(xi)  a(x) dx where the integral is over each cell and  a(x) = a exp(S(x-yₖ))  if the membership of i is -1 and  a(x) = a exp(S(yₖ₁-x))  if the membership of i is 1 where  yₖ and yₖ₊₁ are the left and right cell edges, respectively, and  a and S are defined by dq.mesh.me are parameters of a MatrixExponential.\n\n\n\n\n\n","category":"method"},{"location":"types/#DiscretisedFluidQueues.SFMDistribution-Tuple{Function, DiscretisedFluidQueue{var\"#s40\"} where var\"#s40\"<:Mesh}","page":"Types","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution(pdf::Function, dq::DiscretisedFluidQueue{<:Mesh}, fun_evals::Int = 6)\n\nReturn a discretised version of the pdf. The method of discretisation depends on the discretisation method  of dq.\n\nArguments:\n\npdf::Function: a function f(x::Float64,i::Int) where f(x,i)dx=P(X(0)∈dx,φ(0)=i) is the initial    distribution of a fluid queue.\ndqDiscretisedFluidQueue{<:Mesh}: \nfun_evals: the number of function evaluations used to approximate f(x,i)\n\n\n\n\n\n","category":"method"},{"location":"types/#DiscretisedFluidQueues.SFMDistribution-Union{Tuple{DiscretisedFluidQueue{T}}, Tuple{T}} where T","page":"Types","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution(dq::DiscretisedFluidQueue{T})\n\nA blank initialiser for a fluid queue distribution a distribution with coeffs=zeros.\n\n\n\n\n\n","category":"method"},{"location":"types/#DiscretisedFluidQueues.Simulation","page":"Types","title":"DiscretisedFluidQueues.Simulation","text":"Simulation\n\nA container to hold simulations. \n\nAll arguments are arrays of the same ength + a model from which the simulations came\n\nArguments:\n\nt::Array{Float64, 1}: \nφ::Array{Int, 1}: \nX::Array{Float64, 1}: \nn::Array{Int, 1}: \nmodel::Model: \n\n\n\n\n\n","category":"type"}]
}
