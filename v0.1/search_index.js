var documenterSearchIndex = {"docs":
[{"location":"m_and_d/#Models-and-Discretisations-1","page":"Models and Discretisations","title":"Models and Discretisations","text":"","category":"section"},{"location":"m_and_d/#Model-related-Types-1","page":"Models and Discretisations","title":"Model-related Types","text":"","category":"section"},{"location":"m_and_d/#","page":"Models and Discretisations","title":"Models and Discretisations","text":"Phase\nPhaseSet\nModel\nDiscretisedFluidQueue\nFluidQueue ","category":"page"},{"location":"m_and_d/#DiscretisedFluidQueues.Phase","page":"Models and Discretisations","title":"DiscretisedFluidQueues.Phase","text":"Phase\n\nRepresents a phase of the fluid queue.\n\nArguments:\n\nc::Float64: the rate of change of the fluid X(t) associated with the phase\nm::Int64: either -1 or 1, membership of the phase with either the set of positive or negative phases.   Default is positive, i.e. 1. Only relevant for FRAPApproximation.\nlpm::Bool: whether the phase has a point mass at the left/lower boundary\nrpm::Bool: whether the phase has a point mass at the right/upper boundary\n\n\n\n\n\n","category":"type"},{"location":"m_and_d/#DiscretisedFluidQueues.PhaseSet","page":"Models and Discretisations","title":"DiscretisedFluidQueues.PhaseSet","text":"const PhaseSet = Array{Phase,1}\n\nA container for phases.\n\n\n\n\n\n","category":"type"},{"location":"m_and_d/#DiscretisedFluidQueues.Model","page":"Models and Discretisations","title":"DiscretisedFluidQueues.Model","text":"Model\n\nAbstract type represnting a FluidQueue or DiscretisedFluidQueue\n\n\n\n\n\n","category":"type"},{"location":"m_and_d/#DiscretisedFluidQueues.DiscretisedFluidQueue","page":"Models and Discretisations","title":"DiscretisedFluidQueues.DiscretisedFluidQueue","text":"DiscretisedFluidQueue{T <: Mesh}\n\nA container to hold a FluidQueue and a discretisation scheme (a mesh).  Parametric type depending on the type of discretisation scheme (<:Mesh)\n\nArguments:\n\nmodel::Model: a FluidQueue\nmesh::T: either a DGMesh, FVMesh or FRAPMesh specifying the discretisation scheme for the    continuous level of the fluid queue, X(t). \n\n\n\n\n\n","category":"type"},{"location":"m_and_d/#DiscretisedFluidQueues.FluidQueue","page":"Models and Discretisations","title":"DiscretisedFluidQueues.FluidQueue","text":"FluidQueue <: Model\n\nConstructor for a fluid queue model.\n\nArguments:\n\nT::Array{<:Real, 2}: Generator of the phase process\nS::PhaseSet: An array of phases describing the evolution of the fluid level in each phase.\n\n\n\n\n\n","category":"type"},{"location":"m_and_d/#Mesh-(discretisation)-related-Types-1","page":"Models and Discretisations","title":"Mesh (discretisation)-related Types","text":"","category":"section"},{"location":"m_and_d/#","page":"Models and Discretisations","title":"Models and Discretisations","text":"Mesh\nDGMesh\nFRAPMesh\nFVMesh","category":"page"},{"location":"m_and_d/#DiscretisedFluidQueues.Mesh","page":"Models and Discretisations","title":"DiscretisedFluidQueues.Mesh","text":"Mesh\n\nAbstract type representing a discretisation mesh for a numerical scheme. \n\n\n\n\n\n","category":"type"},{"location":"m_and_d/#DiscretisedFluidQueues.DGMesh","page":"Models and Discretisations","title":"DiscretisedFluidQueues.DGMesh","text":"DGMesh <: Mesh\n\nA structure representing a discretisation scheme to be used for a DiscretisedFluidQueue. \n\nArguments:\n\nnodes::Array{<:Real, 1}: The edges of the cells.\nn_bases::Int: The number of basis functions used to represent the solution on each cell\n\n\n\n\n\n","category":"type"},{"location":"m_and_d/#DiscretisedFluidQueues.FRAPMesh","page":"Models and Discretisations","title":"DiscretisedFluidQueues.FRAPMesh","text":"FRAPMesh <: Mesh\n\nA QBD-RAP (FRAM) discretisation scheme for a DiscretisedFluidQueue. \n\nArguments\n\nnodes: the cell edges\nme: the MatrixExponential used to approximate model the fluid queue on each cell.\n\n\n\n\n\n","category":"type"},{"location":"m_and_d/#DiscretisedFluidQueues.FVMesh","page":"Models and Discretisations","title":"DiscretisedFluidQueues.FVMesh","text":"FVMesh <: Mesh\n\nA finite volume discretisation scheme for a DiscretisedFluidQueue. \n\nArguments\n\nnodes: the cell edges (the nodes are at the center of the cell)\norder: the order of the polynomial interpolation used to approximate the flux at the \n\ncell edges.\n\n\n\n\n\n","category":"type"},{"location":"m_and_d/#Model-related-Methods-1","page":"Models and Discretisations","title":"Model-related Methods","text":"","category":"section"},{"location":"m_and_d/#","page":"Models and Discretisations","title":"Models and Discretisations","text":"n_phases\nrates\nmembership\nN₋\nN₊\naugment_model","category":"page"},{"location":"m_and_d/#DiscretisedFluidQueues.n_phases","page":"Models and Discretisations","title":"DiscretisedFluidQueues.n_phases","text":"n_phases(S::PhaseSet)\n\nReturn the number of phases from a PhaseSet, FluidQueue, or DiscretisedFluidQueue\n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#DiscretisedFluidQueues.rates","page":"Models and Discretisations","title":"DiscretisedFluidQueues.rates","text":"rates(S::PhaseSet, i::Int)\n\nReturn the rate of the phase from a PhaseSet, FluidQueue, or DiscretisedFluidQueue\n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#DiscretisedFluidQueues.membership","page":"Models and Discretisations","title":"DiscretisedFluidQueues.membership","text":"membership(S::PhaseSet, i::Int)\n\nReturn the membership of phases from a PhaseSet\n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#DiscretisedFluidQueues.N₋","page":"Models and Discretisations","title":"DiscretisedFluidQueues.N₋","text":"N₋(S::PhaseSet)\n\nReturn the number of left/lower point masses of a PhaseSet, FluidQueue or DiscretisedFluidQueue\n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#DiscretisedFluidQueues.N₊","page":"Models and Discretisations","title":"DiscretisedFluidQueues.N₊","text":"N₊(S::PhaseSet) = begin\n\nReturn the number of right/upper point masses of a PhaseSet, FluidQueue or DiscretisedFluidQueue\n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#DiscretisedFluidQueues.augment_model","page":"Models and Discretisations","title":"DiscretisedFluidQueues.augment_model","text":"augment_model(model::FluidQueue)\n\nGiven a FluidQueue, return a FluidQueue with twice as many phases with rate 0, one set associated  with m=1 phases and one associated with m=-1 phases. \n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#Mesh-(discretisation)-related-Methods-1","page":"Models and Discretisations","title":"Mesh (discretisation)-related Methods","text":"","category":"section"},{"location":"m_and_d/#","page":"Models and Discretisations","title":"Models and Discretisations","text":"cell_nodes\nn_intervals\nΔ\nn_bases_per_phase\nn_bases_per_cell\ntotal_n_bases","category":"page"},{"location":"m_and_d/#DiscretisedFluidQueues.cell_nodes","page":"Models and Discretisations","title":"DiscretisedFluidQueues.cell_nodes","text":"cell_nodes(mesh::DGMesh)\n\nThe positions of the GLJ nodes within each cell of a mesh.\n\n\n\n\n\ncell_nodes(mesh::FVMesh)\n\nThe cell centres\n\n\n\n\n\ncell_nodes(mesh::FRAPMesh)\n\nThe cell centre\n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#DiscretisedFluidQueues.n_intervals","page":"Models and Discretisations","title":"DiscretisedFluidQueues.n_intervals","text":"n_intervals(m)\n\nTotal number of cells for a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#DiscretisedFluidQueues.Δ","page":"Models and Discretisations","title":"DiscretisedFluidQueues.Δ","text":"Δ(m)\n\nThe width of each cell for a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\nΔ(m,k::Int)\n\nThe width of cell k for a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#DiscretisedFluidQueues.n_bases_per_phase","page":"Models and Discretisations","title":"DiscretisedFluidQueues.n_bases_per_phase","text":"n_bases_per_phase(m)\n\nTotal number of basis functions used to represent the fluid queue for each phase      of a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#DiscretisedFluidQueues.n_bases_per_cell","page":"Models and Discretisations","title":"DiscretisedFluidQueues.n_bases_per_cell","text":"n_bases_per_cell(m) =\n\nReturn the number of basis functions on each cell of a given DiscretisedFluidQueue or Mesh.\n\n\n\n\n\nn_bases_per_cell(mesh::DGMesh)\n\nNumber of bases in a cell\n\n\n\n\n\nn_bases_per_cell(mesh::FVMesh)\n\nConstant 1\n\n\n\n\n\nn_bases_per_cell(mesh::FRAPMesh)\n\nNumber of bases in a cell\n\n\n\n\n\n","category":"function"},{"location":"m_and_d/#DiscretisedFluidQueues.total_n_bases","page":"Models and Discretisations","title":"DiscretisedFluidQueues.total_n_bases","text":"total_n_bases(m)\n\nReturn the number of basis functions of a given DiscretisedFluidQueue or Mesh.\n\n\n\n\n\n","category":"function"},{"location":"dist/#Distributions-1","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"dist/#Construction-1","page":"Distributions","title":"Construction","text":"","category":"section"},{"location":"dist/#","page":"Distributions","title":"Distributions","text":"SFMDistribution\ninterior_point_mass\nleft_point_mass\nright_point_mass","category":"page"},{"location":"dist/#DiscretisedFluidQueues.SFMDistribution","page":"Distributions","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution{T <: Mesh} <: AbstractArray{Float64, 2}\n\nRepresentation of the distribution of a DiscretisedFluidQueue. \n\nThe field coeffs is a row-vector and indexing a distribution indexes this field. Similarly,  arithmetic operations on a distribution act on this vector.\n\nArguments:\n\ncoeffs::Array{Float64, 2}: A row vector of coefficients which encode the distribution of a    DiscretisedFluidQueue and can be used to reconstruct a solution.\ndq::DiscretisedFluidQueue{T}: \n\n\n\n\n\n","category":"type"},{"location":"dist/#DiscretisedFluidQueues.interior_point_mass","page":"Distributions","title":"DiscretisedFluidQueues.interior_point_mass","text":"interior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{<:Mesh})\n\nConstruct an approximation to a distribution of fluid queue with a point mass at (x,i).  Returns a SFMDistribution. The method of approximation is defined by the type of <:Mesh.\n\nArguments:\n\nx::Float64: The position of the point mass\ni::Int: The phase of the point mass\ndq::DiscretisedFluidQueue: \n\n\n\n\n\ninterior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{DGMesh})\n\nConstructs a polynomial approximation to the point mass at (x,i)\n\n\n\n\n\ninterior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{FVMesh})\n\nConstruct an approximation to a point mass at (x,i). Basically, just puts mass 1 in the cell containing (x,i).\n\n\n\n\n\ninterior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{FRAPMesh})\n\nReturn the appropriate initial condition to approximate the initial distribution which  is a point mass at (x,i) for the numerical discretisation scheme defined by the  dq DiscretisedFluidQueue.\n\ni.e. Compute the orbit position  a(x) = a exp(S(x-yₖ))  if the membership of i is -1 and  a(x) = a exp(S(yₖ₁-x))  if the membership of i is 1 where  yₖ and yₖ₊₁ are the left and right cell edges and x∈[yₖ,yₖ₊₁], respectively, and  a and S are defined by dq.mesh.me are parameters of a MatrixExponential.\n\n\n\n\n\n","category":"function"},{"location":"dist/#DiscretisedFluidQueues.left_point_mass","page":"Distributions","title":"DiscretisedFluidQueues.left_point_mass","text":"left_point_mass(i::Int, dq::DiscretisedFluidQueue)\n\nConstruct a SFMDistribution with a point mass at the left boundary of dq in phase i and 0 elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"dist/#DiscretisedFluidQueues.right_point_mass","page":"Distributions","title":"DiscretisedFluidQueues.right_point_mass","text":"right_point_mass(i::Int, dq::DiscretisedFluidQueue)\n\nConstruct a SFMDistribution with a point mass at the left boundary of dq in phase i and 0 elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"dist/#Reconstructing-solutions-1","page":"Distributions","title":"Reconstructing solutions","text":"","category":"section"},{"location":"dist/#","page":"Distributions","title":"Distributions","text":"pdf(d::SFMDistribution)\npdf(d::SFMDistribution, x, i) \ncdf(d::SFMDistribution)\ncdf(d::SFMDistribution, x, i) ","category":"page"},{"location":"dist/#DiscretisedFluidQueues.pdf-Tuple{SFMDistribution}","page":"Distributions","title":"DiscretisedFluidQueues.pdf","text":"pdf(d::SFMDistribution)\n\nReturn a function of two variables (x::Float64,i::Int) which is the  probability distribution function defined by d. Approximates the density function of  a fluid queue.\n\n\n\n\n\n","category":"method"},{"location":"dist/#DiscretisedFluidQueues.pdf-Tuple{SFMDistribution, Any, Any}","page":"Distributions","title":"DiscretisedFluidQueues.pdf","text":"pdf(d::SFMDistribution, x, i)\n\nEvaluate pdf(d::SFMDistribution) at (x,i).\n\n\n\n\n\n","category":"method"},{"location":"dist/#DiscretisedFluidQueues.cdf-Tuple{SFMDistribution}","page":"Distributions","title":"DiscretisedFluidQueues.cdf","text":"cdf(d::SFMDistribution)\n\nReturn a function of two variables (x::Float64,i::Int) which is the  cumulative distribution distribution function defined by d. Approximates the distribution function of  a fluid queue.\n\n\n\n\n\n","category":"method"},{"location":"dist/#DiscretisedFluidQueues.cdf-Tuple{SFMDistribution, Any, Any}","page":"Distributions","title":"DiscretisedFluidQueues.cdf","text":"cdf(d::SFMDistribution, x, i)\n\nEvaluate cdf(d::SFMDistribution) at (x,i).\n\n\n\n\n\n","category":"method"},{"location":"dist/#Integrate-time-1","page":"Distributions","title":"Integrate time","text":"","category":"section"},{"location":"dist/#","page":"Distributions","title":"Distributions","text":"TimeIntegrationScheme\nEuler\nintegrate_time","category":"page"},{"location":"dist/#DiscretisedFluidQueues.TimeIntegrationScheme","page":"Distributions","title":"DiscretisedFluidQueues.TimeIntegrationScheme","text":"TimeIntegrationScheme\n\n\n\n\n\n","category":"type"},{"location":"dist/#DiscretisedFluidQueues.Euler","page":"Distributions","title":"DiscretisedFluidQueues.Euler","text":"Euler <: TimeIntegrationScheme\n\nDefines an Euler integration scheme to be used in integrate_time.\n\nArguments\n\nstep_size::Float64: the step size of the integration scheme.\n\n\n\n\n\n","category":"type"},{"location":"dist/#DiscretisedFluidQueues.integrate_time","page":"Distributions","title":"DiscretisedFluidQueues.integrate_time","text":"Given x0 apprximate x0 exp(Dy).\n\nintegrate_time(x0::AbstractArray{<:Real, 2}, D::Generator, y::Real, h::TimeIntegrationScheme = Euler(y ./ 1000))\n\nArguments\n\nx0: An initial row vector\nD: A square matrix\ny: time to integrate up to\nh: TimeIntegrationScheme.\n\nOutput\n\n\n\n\n\n\n\n","category":"function"},{"location":"poly/#Polynomial-interpolation-and-tools-1","page":"Polynomial tools","title":"Polynomial interpolation and tools","text":"","category":"section"},{"location":"poly/#","page":"Polynomial tools","title":"Polynomial tools","text":"DG and FV methods rely on polynomial approximations. ","category":"page"},{"location":"poly/#","page":"Polynomial tools","title":"Polynomial tools","text":"DiscretisedFluidQueues.lagrange_polynomials\nDiscretisedFluidQueues.gauss_lobatto_points\nDiscretisedFluidQueues.gauss_lobatto_weights\nDiscretisedFluidQueues.lagrange_interpolation\nDiscretisedFluidQueues.gauss_lobatto_quadrature\nDiscretisedFluidQueues.vandermonde","category":"page"},{"location":"poly/#DiscretisedFluidQueues.lagrange_polynomials","page":"Polynomial tools","title":"DiscretisedFluidQueues.lagrange_polynomials","text":"lagrange_polynomials(nodes::Array{Float64, 1}, evalPt::Float64)\n\nEvaluate the lagrange polynomials defied by nodes at the point evalPt.\n\n\n\n\n\n","category":"function"},{"location":"poly/#DiscretisedFluidQueues.gauss_lobatto_points","page":"Polynomial tools","title":"DiscretisedFluidQueues.gauss_lobatto_points","text":"gauss_lobatto_points(a::Float64, b::Float64, n_evals::Int)\n\nReturn array containing n_evals gauss lobatto points in the interval [a,b].\n\n\n\n\n\n","category":"function"},{"location":"poly/#DiscretisedFluidQueues.gauss_lobatto_weights","page":"Polynomial tools","title":"DiscretisedFluidQueues.gauss_lobatto_weights","text":"gauss_lobatto_weights(a::Float64, b::Float64, n_evals::Int)\n\nReturn array containing n_evals weights of the polynomials associated with the gauss lobatto points in the interval [a,b]. i.e. the itegrals over the interval [a,b]  of the lagrange polynomials defined by the nodes given by nodes = gauss_lobatto_points(a,b,n_evals)\n\n\n\n\n\n","category":"function"},{"location":"poly/#DiscretisedFluidQueues.lagrange_interpolation","page":"Polynomial tools","title":"DiscretisedFluidQueues.lagrange_interpolation","text":"lagrange_interpolation(fun::Function, a::Float64, b::Float64, n_evals::Int)\n\nReturn a polynomial approximation to fun of order n_evals-1 on the interval [a,b] using  the gauss_lobatto_points as the nodes of the lagrange polynomials.\n\n\n\n\n\n","category":"function"},{"location":"poly/#DiscretisedFluidQueues.gauss_lobatto_quadrature","page":"Polynomial tools","title":"DiscretisedFluidQueues.gauss_lobatto_quadrature","text":"gauss_lobatto_quadrature(fun::Function, a::Float64, b::Float64, n_evals::Int)\n\nCompute a quadrature approximation of fun on the interval [a,b] with n_evals function  evaluations using the gauss_lobatto_points\n\n\n\n\n\n","category":"function"},{"location":"poly/#DiscretisedFluidQueues.vandermonde","page":"Polynomial tools","title":"DiscretisedFluidQueues.vandermonde","text":"Construct a generalised vandermonde matrix.\n\nvandermonde( nBases::Int)\n\nNote: requires Jacobi package Pkg.add(\"Jacobi\")\n\nArguments\n\nnBases::Int: the degree of the basis\n\nOutput\n\na tuple with keys\n:V::Array{Float64,2}: where :V[:,i] contains the values of the ith   legendre polynomial evaluate at the GLL nodes.\n:inv: the inverse of :V\n:D::Array{Float64,2}: where V.D[:,i] contains the values of the derivative   of the ith legendre polynomial evaluate at the GLL nodes.\n\n\n\n\n\n","category":"function"},{"location":"generators/#Generators-1","page":"Generators","title":"Generators","text":"","category":"section"},{"location":"generators/#","page":"Generators","title":"Generators","text":"Generator\nLazyGenerator\nFullGenerator\nbuild_lazy_generator\nbuild_full_generator\nsize","category":"page"},{"location":"generators/#DiscretisedFluidQueues.Generator","page":"Generators","title":"DiscretisedFluidQueues.Generator","text":"Generator\n\nAbstract type representing a discretised infinitesimal generator of a FLuidQueue.\n\n\n\n\n\n","category":"type"},{"location":"generators/#DiscretisedFluidQueues.LazyGenerator","page":"Generators","title":"DiscretisedFluidQueues.LazyGenerator","text":"LazyGenerator <: Generator\n\nA lazy representation of a block matrix with is a generator of a DiscretisedFluidQueue.\n\nLower memory requirements than FullGenerator but aritmetic operations and indexing may be slower.\n\nArguments:\n\ndq::DiscretisedFluidQueue: \nblocks::Tuple{Array{Float64, 2}, Array{Float64, 2}, Array{Float64, 2}, Array{Float64, 2}}:    Block matrices describing the flow of mass within and between cells. blocks[1] is the lower    diagonal block describing the flow of mass from cell k+1 to cell (k for phases    with negative rate only). blocks[2] (blocks[3]) is the    diagonal block describing the flow of mass within a cell for a phase with positive (negative) rate.   blocks[4] is the upper diagonal block describing the flow of mass from cell k to k+1 (for phases    with positive rate only).  \nboundary_flux::BoundaryFluxTupleType: A named tuple structure such that        - boundary_flux.lower.in: describes flow of density into lower boundary       - boundary_flux.lower.out: describes flow of density out of lower boundary       - boundary_flux.upper.in: describes flow of density into upper boundary       - boundary_flux.upper.out: describes flow of density out of upper boundary\nD::Union{Array{Float64, 2}, LinearAlgebra.Diagonal{Bool, Array{Bool, 1}}}: An array describing    how the flow of density changes when the phase process jumps between phases with different memberships.   This is the identity for FV and DG schemes. \n\n\n\n\n\n","category":"type"},{"location":"generators/#DiscretisedFluidQueues.FullGenerator","page":"Generators","title":"DiscretisedFluidQueues.FullGenerator","text":"FullGenerator <: Generator\n\nAn Matrix or SparseMatrixCSC representation of the generator of a generator of a DiscretisedFluidQueue.\n\nHigher memory requirements than LazyGenerator (as blocks are duplicated) but much faster matrix arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"generators/#DiscretisedFluidQueues.build_lazy_generator","page":"Generators","title":"DiscretisedFluidQueues.build_lazy_generator","text":"build_lazy_generator(dq::DiscretisedFluidQueue; v::Bool = false)\n\nBuild a lazy representation of the generator of a discretised fluid queue.\n\n\n\n\n\n","category":"function"},{"location":"generators/#DiscretisedFluidQueues.build_full_generator","page":"Generators","title":"DiscretisedFluidQueues.build_full_generator","text":"build_full_generator(dq::DiscretisedFluidQueue; v::Bool = false)\n\nReturns a SparseMatrixCSC generator of a DiscretisedFluidQueue.\n\n\n\n\n\nbuild_full_generator(lzB::LazyGenerator)\n\nReturns a SparseMatrixCSC representation of a LazyGenerator.\n\n\n\n\n\n","category":"function"},{"location":"generators/#Base.size","page":"Generators","title":"Base.size","text":"size(B::LazyGenerator)\n\n\n\n\n\n","category":"function"},{"location":"sim/#Simulate-1","page":"Simulate","title":"Simulate","text":"","category":"section"},{"location":"sim/#","page":"Simulate","title":"Simulate","text":"Tools to simulate a FluidQueue. ","category":"page"},{"location":"sim/#Simulate-and-evaluate-simulations-1","page":"Simulate","title":"Simulate and evaluate simulations","text":"","category":"section"},{"location":"sim/#","page":"Simulate","title":"Simulate","text":"Simulation\nsimulate\ncdf(s::Simulation)","category":"page"},{"location":"sim/#DiscretisedFluidQueues.Simulation","page":"Simulate","title":"DiscretisedFluidQueues.Simulation","text":"Simulation\n\nA container to hold simulations. \n\nAll arguments are arrays of the same ength + a model from which the simulations came\n\nArguments:\n\nt::Array{Float64, 1}: \nφ::Array{Int, 1}: \nX::Array{Float64, 1}: \nn::Array{Int, 1}: \nmodel::Model: \n\n\n\n\n\n","category":"type"},{"location":"sim/#DiscretisedFluidQueues.simulate","page":"Simulate","title":"DiscretisedFluidQueues.simulate","text":"Simulates a SFM defined by Model until the StoppingTime has occured, given the InitialCondition on (φ(0),X(0)).\n\nsimulate(\n    model::Model,\n    lwr::Float64, upr::Float64,\n    StoppingTime::Function,\n    InitCondition::NamedTuple{(:φ, :X)},\n)\n\nArguments\n\nmodel: A Model object \nlwr and upr upper an lower regulated boundaries for the fluid level.\nStoppingTime: A function which takes the value of the process at the current   time and at the time of the last jump of the phase process, as well as the   model object.   i.e. StoppingTime(;model,SFM,SFM0,lwer,upr) where SFM and SFM0 are tuples with   keys (:t::Float64, :φ::Int, :X::Float64, :n::Int) which are the value of   the SFM at the current time, and time of the previous jump of the phase   process, repsectively. The StoppingTime must return a   NamedTuple{(:Ind, :SFM)} type where :Ind is a :Bool value stating   whether the stopping time has occured or not and :SFM is a tuple in the   same form as the input SFM but which contains the value of the SFM at   the stopping time.\nInitCondition: NamedTuple with keys (:φ, :X), InitCondition.φ is a   vector of length M of initial states for the phase, and InitCondition.X   is a vector of length M of initial states for the level. M is the number   of simulations to be done.\n\nOutput\n\nA Simulation object.\n\n\n\n\n\n","category":"function"},{"location":"sim/#DiscretisedFluidQueues.cdf-Tuple{Simulation}","page":"Simulate","title":"DiscretisedFluidQueues.cdf","text":"cdf(s::Simulation)\n\nReturn a empirical cdf of the fluid queue given a simulation. \n\nOutput is a function of two variables (x,i) and gives the empirical distribution      function P(X(τ)xφ(τ)=i)\n\n\n\n\n\n","category":"method"},{"location":"sim/#","page":"Simulate","title":"Simulate","text":"","category":"page"},{"location":"sim/#Predefined-stopping-times-1","page":"Simulate","title":"Predefined stopping times","text":"","category":"section"},{"location":"sim/#","page":"Simulate","title":"Simulate","text":"fixed_time\nn_jumps\nfirst_exit_x","category":"page"},{"location":"sim/#DiscretisedFluidQueues.fixed_time","page":"Simulate","title":"DiscretisedFluidQueues.fixed_time","text":"Constructs the StoppingTime 1(tT)\n\nfixed_time( T::Real)\n\nArguments\n\nT: a time at which to stop the process\n\nOutput\n\nfixed_timeFun: a function with one methods\n`fixed_timeFun(   model::Model,   SFM::NamedTuple{(:t, :φ, :X, :n)},   SFM0::NamedTuple{(:t, :φ, :X, :n)},   lwr::Float64,   upr::Float64,\n)`: a stopping time for a SFM.\n\n\n\n\n\n","category":"function"},{"location":"sim/#DiscretisedFluidQueues.n_jumps","page":"Simulate","title":"DiscretisedFluidQueues.n_jumps","text":"Constructs the StoppingTime 1(N(t)n) where N(t) is the number of jumps of φ by time t.\n\nn_jumps( N::Int)\n\nArguments\n\nN: a desired number of jumps\n\nOutput\n\nn_jumpsFun: a function with one methods\n`n_jumpsFun(   model::Model,   SFM::NamedTuple{(:t, :φ, :X, :n)},   SFM0::NamedTuple{(:t, :φ, :X, :n)},   lwr::Float64,   upr::Float64,\n)`: a stopping time for a SFM.\n\n\n\n\n\n","category":"function"},{"location":"sim/#DiscretisedFluidQueues.first_exit_x","page":"Simulate","title":"DiscretisedFluidQueues.first_exit_x","text":"Constructs the StoppingTime which is the first exit of the process X(t) from the interval uv.\n\nfirst_exit_x( u::Real, v::Real)\n\nArguments\n\nu: a lower boundary\nv: an upper boundary\n\nOutput\n\nfirst_exit_xFun: a function with one methods\n`firstexitxFun(   model::Model,   SFM::NamedTuple{(:t, :φ, :X, :n)},   SFM0::NamedTuple{(:t, :φ, :X, :n)},   lwr::Float64,   upr::Float64,\n)`: a stopping time for a SFM.\n\n\n\n\n\n","category":"function"},{"location":"#DiscretisedFluidQueues-1","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"","category":"section"},{"location":"#Numerical-approximation-schemes-for-stochastic-fluid-queues.-1","page":"DiscretisedFluidQueues","title":"Numerical approximation schemes for stochastic fluid queues.","text":"","category":"section"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"The evolution of a stochastic fluid queue with generator T_ij_ijin S and associated diagonal matrix of rates C = diag(c_iiin S) can be described by the PDE (when it exists)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"cfracpartialpartial t  mathbf f(xit) =  mathbf f(xit) T - cfracpartialpartial x  mathbf f(xit) C","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"where mathbf f(xit) dx = (f(xit))_iin S = (P(X(t)in dx varphi(t)=i))_iin S the time-dependent joint density/mass function. ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"This package implements finite element and finite volume numerical solvers to approximate the right-hand side of this PDE; ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Discontinuous Galerkin: projects the right-hand side of the PDE on to a basis of polynomials,\nFinite volume:\nQBD-RAP approximation: use matrix-exponential distributions to model the solution locally on each cell.","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"","category":"page"},{"location":"#Usage-1","page":"DiscretisedFluidQueues","title":"Usage","text":"","category":"section"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"pkg> add https://github.com/angus-lewis/DiscretisedFluidQueues","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"julia> using DiscretisedFluidQueues","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Create a model with (for example)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"T = [-2.5 2 0.5; 1 -2 1; 1 2 -3] # generator of the phase\nC = [0.0; 2.0; -3.0]    # rates dX/dt\n\nS = PhaseSet(C) \n\nmodel = FluidQueue(T,S) ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Create a discretisation mesh (a grid + method with which to approximate the solution) with any of (e.g.)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"nbases = 3\nmesh = DGMesh(nodes,nbases)\n\nfv_order = 3\nfvmesh = FVMesh(nodes,fv_order)\n\norder = 3\nfrapmesh = FRAPMesh(nodes,order)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Combine the model and the discretisation scheme (mesh) to form a discretised fluid queue","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"dq = DiscretisedFluidQueue(model,mesh)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Construct an approximation to the generator with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"B = build_full_generator(dq)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"B is essentially a matrix which we can think of as describing the ODE","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"fracpartialpartial t   mathbf a(t) =   mathbf a(t) B","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"where $ \\mathbf a(t)$ is a row vector of coefficients and $  \\mathbf a(t)  \\mathbf u(x,i) \\approx  \\mathbf f(x,i,t)$ approximates the solution where $ \\mathbf u(x,i)$ is a column vector of functions defined by the discretisation scheme.","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Construct an initial distribution with (e.g.)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"f(x,i) = (i-1)/12.0./sum(1:3) # the initial distribution\nd = SFMDistribution(f,dq)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Integrate over time with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"t = 3.2\ndt = integrate_time(d,B,t)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Reconstruct approximate solution with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"u = cdf(d)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Evaluate solution as a function ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"u(0.1,1) # = P(X(3.2)<0.1, phi(3.2)=1)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"More examples and documentation to come. ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"This is my PhD topic. I'll provide a link to a write up when I've done one...","category":"page"},{"location":"me_tools/#ME-Tools-1","page":"ME Tools","title":"ME Tools","text":"","category":"section"},{"location":"me_tools/#Types-1","page":"ME Tools","title":"Types","text":"","category":"section"},{"location":"me_tools/#","page":"ME Tools","title":"ME Tools","text":"AbstractMatrixExponential\nConcentratedMatrixExponential\nMatrixExponential \ncme_params","category":"page"},{"location":"me_tools/#DiscretisedFluidQueues.AbstractMatrixExponential","page":"ME Tools","title":"DiscretisedFluidQueues.AbstractMatrixExponential","text":"AbstractMatrixExponential\n\n\n\n\n\n","category":"type"},{"location":"me_tools/#DiscretisedFluidQueues.ConcentratedMatrixExponential","page":"ME Tools","title":"DiscretisedFluidQueues.ConcentratedMatrixExponential","text":"Similar to MatrixExponential but has a neater implementation of orbit() due to nice structure.\n\n\n\n\n\n","category":"type"},{"location":"me_tools/#DiscretisedFluidQueues.MatrixExponential","page":"ME Tools","title":"DiscretisedFluidQueues.MatrixExponential","text":"MatrixExponential constructor method\n\nMatrixExponential(\n    a::Array{Float64,2},\n    S::Array{Float64,2},\n    s::Array{Float64,1},\n    D::Array{Float64}=[0],\n)\n\nInputs: \n\na a 1 by p Array of reals\nS a p by p Array of reals\ns a p by 1 Array of reals\nD an optional argument, if empty then me.D is the identity,   else is a p by p matrix\n\nThrows an error if the dimensions are inconsistent.\n\n\n\n\n\n","category":"type"},{"location":"me_tools/#DiscretisedFluidQueues.cme_params","page":"ME Tools","title":"DiscretisedFluidQueues.cme_params","text":"cme_params\n\nA Dict storing parameters of concentrated matrix exponential distributions. See https://github.com/ghorvath78/iltcme.\n\n\n\n\n\n","category":"constant"},{"location":"me_tools/#Methods-1","page":"ME Tools","title":"Methods","text":"","category":"section"},{"location":"me_tools/#","page":"ME Tools","title":"ME Tools","text":"build_me\npdf(a::Array{Float64,2}, me::AbstractMatrixExponential)\nccdf(a::Array{Float64,2}, me::AbstractMatrixExponential)\ncdf(a::Array{Float64,2}, me::AbstractMatrixExponential)","category":"page"},{"location":"me_tools/#DiscretisedFluidQueues.build_me","page":"ME Tools","title":"DiscretisedFluidQueues.build_me","text":"build_me(params; mean::Real = 1)\n\nReturn a ConcentratedMatrixExponential as defined by the dictionary params. i.e. see CMEParams[3] for an order 3 CME. \n\n\n\n\n\n","category":"function"},{"location":"me_tools/#DiscretisedFluidQueues.pdf-Tuple{Matrix{Float64}, AbstractMatrixExponential}","page":"ME Tools","title":"DiscretisedFluidQueues.pdf","text":"pdf([a::Array{Float64, 2},] me::AbstractMatrixExponential)\n\nReturn a the probability density function of a matrix exponential as a function.\n\nIf a is not specified then the initial vector of the me is me.a\n\nArguments:\n\na: a row vector with length size(me.S,1)\n\n\n\n\n\n","category":"method"},{"location":"me_tools/#DiscretisedFluidQueues.ccdf-Tuple{Matrix{Float64}, AbstractMatrixExponential}","page":"ME Tools","title":"DiscretisedFluidQueues.ccdf","text":"ccdf(a::Array{Float64, 2}, me::AbstractMatrixExponential)\n\nReturn a the complimentary cumulative distribution function (1-cdf) of a matrix exponential as a function.\n\nIf a is not specified then the initial vector of the me is me.a\n\nArguments:\n\na: a row vector with length size(me.S,1)\n\n\n\n\n\n","category":"method"},{"location":"me_tools/#DiscretisedFluidQueues.cdf-Tuple{Matrix{Float64}, AbstractMatrixExponential}","page":"ME Tools","title":"DiscretisedFluidQueues.cdf","text":"cdf(a::Array{Float64, 2}, me::AbstractMatrixExponential) = begin\n\nReturn a the cumulative distribution function of a matrix exponential as a function.\n\nIf a is not specified then the initial vector of the me is me.a\n\nArguments:\n\na: a row vector with length size(me.S,1)\n\n\n\n\n\n","category":"method"},{"location":"sfm/#SFM-operators-1","page":"Matrix-analytic methods tools","title":"SFM operators","text":"","category":"section"},{"location":"sfm/#","page":"Matrix-analytic methods tools","title":"Matrix-analytic methods tools","text":"Tools to evaluate the stationary distribution of a FluidQueue via matrix-analytic methods. ","category":"page"},{"location":"sfm/#","page":"Matrix-analytic methods tools","title":"Matrix-analytic methods tools","text":"psi_fun_x\nxi_x\nstationary_distribution_x","category":"page"},{"location":"sfm/#DiscretisedFluidQueues.psi_fun_x","page":"Matrix-analytic methods tools","title":"DiscretisedFluidQueues.psi_fun_x","text":"Construct and evaluate Ψ(s) for a triditional SFM.\n\nUses newtons method to solve the Ricatti equation D(s) + Ψ(s)D(s)Ψ(s) + Ψ(s)D(s) + D(s)Ψ(s) = 0\n\npsi_fun_x( model::Model; s = 0, MaxIters = 1000, err = 1e-8)\n\nArguments\n\nmodel: a Model object\ns::Real: a value to evaluate the LST at\nMaxIters::Int: the maximum number of iterations of newtons method\nerr::Float64: an error tolerance for terminating newtons method. Terminates   when max(Ψ_{n} - Ψ{n-1}) .< eps.\n\nOutput\n\nΨ(s)::Array{Float64,2} the matrix Ψ\n\n\n\n\n\n","category":"function"},{"location":"sfm/#DiscretisedFluidQueues.xi_x","page":"Matrix-analytic methods tools","title":"DiscretisedFluidQueues.xi_x","text":"Construct the vector ξ containing the distribution of the phase at the time when X(t) first hits 0.\n\nxi_x( model::Model, Ψ::Array)\n\nArguments\n\nmodel: a Model object\nΨ: an array as output from psi_fun_x\n\nOutput\n\nthe vector ξ\n\n\n\n\n\n","category":"function"},{"location":"sfm/#DiscretisedFluidQueues.stationary_distribution_x","page":"Matrix-analytic methods tools","title":"DiscretisedFluidQueues.stationary_distribution_x","text":"Construct the stationary distribution of the SFM\n\nstationary_distribution_x( model::Model, Ψ::Array, ξ::Array)\n\nArguments\n\nmodel: a Model object\nΨ: an array as output from psi_fun_x\nξ: an array as returned from xi_x\n\nOutput\n\npₓ::Array{Float64,2}: the point masses of the SFM\nπₓ(x) a function with two methods\nπₓ(x::Real): for scalar inputs, returns the stationary density evaluated   at x in all phases.\nπₓ(x::Array): for array inputs, returns an array with the same shape   as is output by Coeff2Dist.\nK::Array{Float64,2}: the matrix in the exponential of the density.\n\n\n\n\n\n","category":"function"}]
}
