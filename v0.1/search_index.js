var documenterSearchIndex = {"docs":
[{"location":"#DiscretisedFluidQueues-1","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"","category":"section"},{"location":"#Numerical-approximation-schemes-for-stochastic-fluid-queues.-1","page":"DiscretisedFluidQueues","title":"Numerical approximation schemes for stochastic fluid queues.","text":"","category":"section"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"The evolution of a stochastic fluid queue with generator <img src=\"https://render.githubusercontent.com/render/math?math=T=[T{ij}]{i,j\\in S}\"> and associated diagonal matrix of rates <img src=\"https://render.githubusercontent.com/render/math?math=C = diag(c_i,i\\in S)\"> can be described by the PDE (when it exists)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"<img src=\"https://render.githubusercontent.com/render/math?math=\\cfrac{\\partial}{\\partial t}  \\mathbf f(x,i,t) =  \\mathbf f(x,i,t) T - \\cfrac{\\partial}{\\partial x}  \\mathbf f(x,i,t) C\">","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"where <img src=\"https://render.githubusercontent.com/render/math?math=\\mathbf f(x,i,t) dx = (f(x,i,t)){i\\in S} = (P(X(t)\\in dx, \\varphi(t)=i)){i\\in S}\"> the time-dependent joint density/mass function. ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"This package implements finite element and finite volume numerical solvers to approximate the right-hand side of this PDE; ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Discontinuous Galerkin: projects the right-hand side of the PDE on to a basis of polynomials,\nFinite volume:\nQBD-RAP approximation: use matrix-exponential distributions to model the solution locally on each cell.","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"","category":"page"},{"location":"#Usage-1","page":"DiscretisedFluidQueues","title":"Usage","text":"","category":"section"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"pkg> add https://github.com/angus-lewis/DiscretisedFluidQueues","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"julia> using DiscretisedFluidQueues","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Create a model with (for example)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"T = [-2.5 2 0.5; 1 -2 1; 1 2 -3] # generator of the phase\nC = [0.0; 2.0; -3.0]    # rates dX/dt\n\nS = PhaseSet(C) \n\nmodel = FluidQueue(T,S) ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Create a discretisation mesh (a grid + method with which to approximate the solution) with any of (e.g.)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"nbases = 3\nmesh = DGMesh(nodes,nbases)\n\nfv_order = 3\nfvmesh = FVMesh(nodes,fv_order)\n\norder = 3\nfrapmesh = FRAPMesh(nodes,order)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Combine the model and the discretisation scheme (mesh) to form a discretised fluid queue","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"dq = DiscretisedFluidQueue(model,mesh)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Construct an approximation to the generator with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"B = build_full_generator(dq)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"B is essentially a matrix which we can think of as describing the ODE \\begin{equation}     \\frac{\\partial}{\\partial t}   \\mathbf a(t) =   \\mathbf a(t) B \\end{equation} where $ \\mathbf a(t)$ is a row vector of coefficients and $  \\mathbf a(t)  \\mathbf u(x,i) \\approx  \\mathbf f(x,i,t)$ approximates the solution where $ \\mathbf u(x,i)$ is a column vector of functions defined by the discretisation scheme.","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Construct an initial distribution with (e.g.)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"f(x,i) = (i-1)/12.0./sum(1:3) # the initial distribution\nd = SFMDistribution(f,dq)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Integrate over time with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"t = 3.2\ndt = integrate_time(d,B,t)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Reconstruct approximate solution with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"u = cdf(d)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Evaluate solution as a function ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"u(0.1,1) # = P(X(3.2)<0.1, phi(3.2)=1)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"More examples and documentation to come. ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"This is my PhD topic. I'll provide a link to a write up when I've done one...","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Modules = [DiscretisedFluidQueues]\nOrder   = [:function, :type]","category":"page"},{"location":"#DiscretisedFluidQueues.N₊-Tuple{Vector{Phase}}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.N₊","text":"N₊(S::PhaseSet) = begin\n\nReturn the number of right/upper point masses of a PhaseSet, FluidQueue or DiscretisedFluidQueue\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.N₋-Tuple{Vector{Phase}}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.N₋","text":"N₋(S::PhaseSet)\n\nReturn the number of left/lower point masses of a PhaseSet, FluidQueue or DiscretisedFluidQueue\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.augment_model-Tuple{FluidQueue}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.augment_model","text":"augment_model(model::FluidQueue)\n\nGiven a FluidQueue, return a FluidQueue with twice as many phases with rate 0, one set associated  with m=1 phases and one associated with m=-1 phases. \n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.build_full_generator-Tuple{DiscretisedFluidQueue}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.build_full_generator","text":"build_full_generator(dq::DiscretisedFluidQueue; v::Bool = false)\n\nReturns a SparseMatrixCSC generator of a DiscretisedFluidQueue.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.build_full_generator-Tuple{LazyGenerator}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.build_full_generator","text":"build_full_generator(lzB::LazyGenerator)\n\nReturns a SparseMatrixCSC representation of a LazyGenerator.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.build_lazy_generator-Tuple{DiscretisedFluidQueue}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.build_lazy_generator","text":"build_lazy_generator(dq::DiscretisedFluidQueue; v::Bool = false)\n\nBuild a lazy representation of the generator of a discretised fluid queue.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.build_me-Tuple{Any}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.build_me","text":"build_me(params; mean::Real = 1)\n\nReturn a ConcentratedMatrixExponential as defined by the dictionary params. i.e. see CMEParams[3] for an order 3 CME. \n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.ccdf-Tuple{Matrix{Float64}, AbstractMatrixExponential, Real}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.ccdf","text":"ccdf(a::Array{Float64, 2}, me::AbstractMatrixExponential, x::Real)\n\nReturn a the complimentary cumulative distribution function (1-cdf) of a matrix exponential evaluated at x.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.ccdf-Tuple{Matrix{Float64}, AbstractMatrixExponential}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.ccdf","text":"ccdf(a::Array{Float64, 2}, me::AbstractMatrixExponential)\n\nReturn a the complimentary cumulative distribution function (1-cdf) of a matrix exponential as a function.\n\nIf a is not specified then the initial vector of the me is me.a\n\nArguments:\n\na: a row vector with length size(me.S,1)\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.cdf-Tuple{Matrix{Float64}, AbstractMatrixExponential, Real}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.cdf","text":"cdf(a::Array{Float64, 2}, me::AbstractMatrixExponential, x::Real)\n\nReturn a the cumulative distribution function of a matrix exponential evaluated at x.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.cdf-Tuple{Matrix{Float64}, AbstractMatrixExponential}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.cdf","text":"cdf(a::Array{Float64, 2}, me::AbstractMatrixExponential) = begin\n\nReturn a the cumulative distribution function of a matrix exponential as a function.\n\nIf a is not specified then the initial vector of the me is me.a\n\nArguments:\n\na: a row vector with length size(me.S,1)\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.cdf-Tuple{SFMDistribution, Any, Any}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.cdf","text":"cdf(d::SFMDistribution, x, i)\n\nEvaluate cdf(d::SFMDistribution) at (x,i).\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.cdf-Tuple{SFMDistribution}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.cdf","text":"cdf(d::SFMDistribution)\n\nReturn a function of two variables (x::Float64,i::Int) which is the  cumulative distribution distribution function defined by d. Approximates the distribution function of  a fluid queue.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.cdf-Tuple{Simulation}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.cdf","text":"cdf(s::Simulation)\n\nReturn a empirical cdf of the fluid queue given a simulation. \n\nOutput is a function of two variables (x,i) and gives the empirical distribution      function P(X(τ)xφ(τ)=i)\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.cell_nodes-Tuple{DGMesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.cell_nodes","text":"cell_nodes(mesh::DGMesh)\n\nThe positions of the GLJ nodes within each cell of a mesh.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.cell_nodes-Tuple{FRAPMesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.cell_nodes","text":"cell_nodes(mesh::FRAPMesh)\n\nThe cell centre\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.cell_nodes-Tuple{FVMesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.cell_nodes","text":"cell_nodes(mesh::FVMesh)\n\nThe cell centres\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.first_exit_x-Tuple{Real, Real}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.first_exit_x","text":"Constructs the StoppingTime which is the first exit of the process X(t) from the interval uv.\n\nfirst_exit_x( u::Real, v::Real)\n\nArguments\n\nu: a lower boundary\nv: an upper boundary\n\nOutput\n\nfirst_exit_xFun: a function with one methods\n`firstexitxFun(   model::Model,   SFM::NamedTuple{(:t, :φ, :X, :n)},   SFM0::NamedTuple{(:t, :φ, :X, :n)},   lwr::Float64,   upr::Float64,\n)`: a stopping time for a SFM.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.fixed_time-Tuple{Float64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.fixed_time","text":"Constructs the StoppingTime 1(tT)\n\nfixed_time( T::Real)\n\nArguments\n\nT: a time at which to stop the process\n\nOutput\n\nfixed_timeFun: a function with one methods\n`fixed_timeFun(   model::Model,   SFM::NamedTuple{(:t, :φ, :X, :n)},   SFM0::NamedTuple{(:t, :φ, :X, :n)},   lwr::Float64,   upr::Float64,\n)`: a stopping time for a SFM.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.integrate_time","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.integrate_time","text":"Given x0 apprximate x0 exp(Dy).\n\nintegrate_time(x0::AbstractArray{<:Real, 2}, D::Generator, y::Real, h::TimeIntegrationScheme = Euler(y ./ 1000))\n\nArguments\n\nx0: An initial row vector\nD: A square matrix\ny: time to integrate up to\nh: TimeIntegrationScheme.\n\nOutput\n\n\n\n\n\n\n\n","category":"function"},{"location":"#DiscretisedFluidQueues.interior_point_mass-Tuple{Float64, Int64, DiscretisedFluidQueue{DGMesh}}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.interior_point_mass","text":"interior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{DGMesh})\n\nConstructs a polynomial approximation to the point mass at (x,i)\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.interior_point_mass-Tuple{Float64, Int64, DiscretisedFluidQueue{FRAPMesh}}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.interior_point_mass","text":"interior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{FRAPMesh})\n\nReturn the appropriate initial condition to approximate the initial distribution which  is a point mass at (x,i) for the numerical discretisation scheme defined by the  dq DiscretisedFluidQueue.\n\ni.e. Compute the orbit position  a(x) = a exp(S(x-yₖ))  if the membership of i is -1 and  a(x) = a exp(S(yₖ₁-x))  if the membership of i is 1 where  yₖ and yₖ₊₁ are the left and right cell edges and x∈[yₖ,yₖ₊₁], respectively, and  a and S are defined by dq.mesh.me are parameters of a MatrixExponential.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.interior_point_mass-Tuple{Float64, Int64, DiscretisedFluidQueue{FVMesh}}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.interior_point_mass","text":"interior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{FVMesh})\n\nConstruct an approximation to a point mass at (x,i). Basically, just puts mass 1 in the cell containing (x,i).\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.interior_point_mass-Tuple{Float64, Int64, DiscretisedFluidQueue{var\"#s40\"} where var\"#s40\"<:Mesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.interior_point_mass","text":"interior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{<:Mesh})\n\nConstruct an approximation to a distribution of fluid queue with a point mass at (x,i).  Returns a SFMDistribution. The method of approximation is defined by the type of <:Mesh.\n\nArguments:\n\nx::Float64: The position of the point mass\ni::Int: The phase of the point mass\ndq::DiscretisedFluidQueue: \n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.left_point_mass-Tuple{Int64, DiscretisedFluidQueue}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.left_point_mass","text":"left_point_mass(i::Int, dq::DiscretisedFluidQueue)\n\nConstruct a SFMDistribution with a point mass at the left boundary of dq in phase i and 0 elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.membership-Tuple{Vector{Phase}, Int64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.membership","text":"membership(S::PhaseSet, i::Int)\n\nReturn the membership of phases from a PhaseSet\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.n_bases_per_cell-Tuple{DGMesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.n_bases_per_cell","text":"n_bases_per_cell(mesh::DGMesh)\n\nNumber of bases in a cell\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.n_bases_per_cell-Tuple{DiscretisedFluidQueue}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.n_bases_per_cell","text":"n_bases_per_cell(m) =\n\nReturn the number of basis functions on each cell of a given DiscretisedFluidQueue or Mesh.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.n_bases_per_cell-Tuple{FRAPMesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.n_bases_per_cell","text":"n_bases_per_cell(mesh::FRAPMesh)\n\nNumber of bases in a cell\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.n_bases_per_cell-Tuple{FVMesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.n_bases_per_cell","text":"n_bases_per_cell(mesh::FVMesh)\n\nConstant 1\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.n_bases_per_phase-Tuple{Mesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.n_bases_per_phase","text":"n_bases_per_phase(m)\n\nTotal number of basis functions used to represent the fluid queue for each phase      of a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.n_intervals-Tuple{Mesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.n_intervals","text":"n_intervals(m)\n\nTotal number of cells for a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.n_jumps-Tuple{Int64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.n_jumps","text":"Constructs the StoppingTime 1(N(t)n) where N(t) is the number of jumps of φ by time t.\n\nn_jumps( N::Int)\n\nArguments\n\nN: a desired number of jumps\n\nOutput\n\nn_jumpsFun: a function with one methods\n`n_jumpsFun(   model::Model,   SFM::NamedTuple{(:t, :φ, :X, :n)},   SFM0::NamedTuple{(:t, :φ, :X, :n)},   lwr::Float64,   upr::Float64,\n)`: a stopping time for a SFM.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.n_phases-Tuple{Vector{Phase}}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.n_phases","text":"n_phases(S::PhaseSet)\n\nReturn the number of phases from a PhaseSet, FluidQueue, or DiscretisedFluidQueue\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.pdf-Tuple{Matrix{Float64}, AbstractMatrixExponential, Real}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.pdf","text":"pdf(a::Array{Float64, 2}, me::AbstractMatrixExponential, x::Real)\n\nReturn a the probability density function of a matrix exponential evaluated at x.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.pdf-Tuple{Matrix{Float64}, AbstractMatrixExponential}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.pdf","text":"pdf([a::Array{Float64, 2},] me::AbstractMatrixExponential)\n\nReturn a the probability density function of a matrix exponential as a function.\n\nIf a is not specified then the initial vector of the me is me.a\n\nArguments:\n\na: a row vector with length size(me.S,1)\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.pdf-Tuple{SFMDistribution, Any, Any}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.pdf","text":"pdf(d::SFMDistribution, x, i)\n\nEvaluate pdf(d::SFMDistribution) at (x,i).\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.pdf-Tuple{SFMDistribution}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.pdf","text":"pdf(d::SFMDistribution)\n\nReturn a function of two variables (x::Float64,i::Int) which is the  probability distribution function defined by d. Approximates the density function of  a fluid queue.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.phases-Tuple{Vector{Phase}}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.phases","text":"phases(S::PhaseSet)\n\nReturn the iterator 1:n_phases(S), for a PhaseSet, FluidQueue, or DiscretisedFluidQueue\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.psi_fun_x-Tuple{Model}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.psi_fun_x","text":"Construct and evaluate Ψ(s) for a triditional SFM.\n\nUses newtons method to solve the Ricatti equation D(s) + Ψ(s)D(s)Ψ(s) + Ψ(s)D(s) + D(s)Ψ(s) = 0\n\npsi_fun_x( model::Model; s = 0, MaxIters = 1000, err = 1e-8)\n\nArguments\n\nmodel: a Model object\ns::Real: a value to evaluate the LST at\nMaxIters::Int: the maximum number of iterations of newtons method\nerr::Float64: an error tolerance for terminating newtons method. Terminates   when max(Ψ_{n} - Ψ{n-1}) .< eps.\n\nOutput\n\nΨ(s)::Array{Float64,2} the matrix Ψ\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.rates-Tuple{Vector{Phase}, Int64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.rates","text":"rates(S::PhaseSet, i::Int)\n\nReturn the rate of the phase from a PhaseSet, FluidQueue, or DiscretisedFluidQueue\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.right_point_mass-Tuple{Int64, DiscretisedFluidQueue}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.right_point_mass","text":"right_point_mass(i::Int, dq::DiscretisedFluidQueue)\n\nConstruct a SFMDistribution with a point mass at the left boundary of dq in phase i and 0 elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.simulate","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.simulate","text":"Simulates a SFM defined by Model until the StoppingTime has occured, given the InitialCondition on (φ(0),X(0)).\n\nsimulate(\n    model::Model,\n    lwr::Float64, upr::Float64,\n    StoppingTime::Function,\n    InitCondition::NamedTuple{(:φ, :X)},\n)\n\nArguments\n\nmodel: A Model object \nlwr and upr upper an lower regulated boundaries for the fluid level.\nStoppingTime: A function which takes the value of the process at the current   time and at the time of the last jump of the phase process, as well as the   model object.   i.e. StoppingTime(;model,SFM,SFM0,lwer,upr) where SFM and SFM0 are tuples with   keys (:t::Float64, :φ::Int, :X::Float64, :n::Int) which are the value of   the SFM at the current time, and time of the previous jump of the phase   process, repsectively. The StoppingTime must return a   NamedTuple{(:Ind, :SFM)} type where :Ind is a :Bool value stating   whether the stopping time has occured or not and :SFM is a tuple in the   same form as the input SFM but which contains the value of the SFM at   the stopping time.\nInitCondition: NamedTuple with keys (:φ, :X), InitCondition.φ is a   vector of length M of initial states for the phase, and InitCondition.X   is a vector of length M of initial states for the level. M is the number   of simulations to be done.\n\nOutput\n\nA Simulation object.\n\n\n\n\n\n","category":"function"},{"location":"#DiscretisedFluidQueues.stationary_distribution_x-Tuple{Model, Array, Array}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.stationary_distribution_x","text":"Construct the stationary distribution of the SFM\n\nstationary_distribution_x( model::Model, Ψ::Array, ξ::Array)\n\nArguments\n\nmodel: a Model object\nΨ: an array as output from psi_fun_x\nξ: an array as returned from xi_x\n\nOutput\n\npₓ::Array{Float64,2}: the point masses of the SFM\nπₓ(x) a function with two methods\nπₓ(x::Real): for scalar inputs, returns the stationary density evaluated   at x in all phases.\nπₓ(x::Array): for array inputs, returns an array with the same shape   as is output by Coeff2Dist.\nK::Array{Float64,2}: the matrix in the exponential of the density.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.total_n_bases-Tuple{DiscretisedFluidQueue}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.total_n_bases","text":"total_n_bases(m)\n\nReturn the number of basis functions of a given DiscretisedFluidQueue or Mesh.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.xi_x-Tuple{Model, Array}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.xi_x","text":"Construct the vector ξ containing the distribution of the phase at the time when X(t) first hits 0.\n\nxi_x( model::Model, Ψ::Array)\n\nArguments\n\nmodel: a Model object\nΨ: an array as output from psi_fun_x\n\nOutput\n\nthe vector ξ\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.Δ-Tuple{Mesh, Any}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.Δ","text":"Δ(m,k::Int)\n\nThe width of cell k for a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.Δ-Tuple{Mesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.Δ","text":"Δ(m)\n\nThe width of each cell for a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.ConcentratedMatrixExponential","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.ConcentratedMatrixExponential","text":"Similar to MatrixExponential but has a neater implementation of orbit() due to nice structure.\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.DGMesh","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.DGMesh","text":"DGMesh <: Mesh\n\nA structure representing a discretisation scheme to be used for a DiscretisedFluidQueue. \n\nArguments:\n\nnodes::Array{<:Real, 1}: The edges of the cells.\nn_bases::Int: The number of basis functions used to represent the solution on each cell\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.DiscretisedFluidQueue","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.DiscretisedFluidQueue","text":"DiscretisedFluidQueue{T <: Mesh}\n\nA container to hold a FluidQueue and a discretisation scheme (a mesh).  Parametric type depending on the type of discretisation scheme (<:Mesh)\n\nArguments:\n\nmodel::Model: a FluidQueue\nmesh::T: either a DGMesh, FVMesh or FRAPMesh specifying the discretisation scheme for the    continuous level of the fluid queue, X(t). \n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.Euler","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.Euler","text":"Euler <: TimeIntegrationScheme\n\nDefines an Euler integration scheme to be used in integrate_time.\n\nArguments\n\nstep_size::Float64: the step size of the integration scheme.\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.FRAPMesh","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.FRAPMesh","text":"FRAPMesh <: Mesh\n\nA QBD-RAP (FRAM) discretisation scheme for a DiscretisedFluidQueue. \n\nArguments\n\nnodes: the cell edges\nme: the MatrixExponential used to approximate model the fluid queue on each cell.\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.FVMesh","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.FVMesh","text":"FVMesh <: Mesh\n\nA finite volume discretisation scheme for a DiscretisedFluidQueue. \n\nArguments\n\nnodes: the cell edges (the nodes are at the center of the cell)\norder: the order of the polynomial interpolation used to approximate the flux at the \n\ncell edges.\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.FluidQueue","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.FluidQueue","text":"FluidQueue <: Model\n\nConstructor for a fluid queue model.\n\nArguments:\n\nT::Array{<:Real, 2}: Generator of the phase process\nS::PhaseSet: An array of phases describing the evolution of the fluid level in each phase.\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.FullGenerator","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.FullGenerator","text":"FullGenerator <: Generator\n\nAn Matrix or SparseMatrixCSC representation of the generator of a generator of a DiscretisedFluidQueue.\n\nHigher memory requirements than LazyGenerator (as blocks are duplicated) but much faster matrix arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.Generator","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.Generator","text":"Generator\n\nAbstract type representing a discretised infinitesimal generator of a FLuidQueue.\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.LazyGenerator","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.LazyGenerator","text":"LazyGenerator <: Generator\n\nA lazy representation of a block matrix with is a generator of a DiscretisedFluidQueue.\n\nLower memory requirements than FullGenerator but aritmetic operations and indexing may be slower.\n\nArguments:\n\ndq::DiscretisedFluidQueue: \nblocks::Tuple{Array{Float64, 2}, Array{Float64, 2}, Array{Float64, 2}, Array{Float64, 2}}:    Block matrices describing the flow of mass within and between cells. blocks[1] is the lower    diagonal block describing the flow of mass from cell k+1 to cell (k for phases    with negative rate only). blocks[2] (blocks[3]) is the    diagonal block describing the flow of mass within a cell for a phase with positive (negative) rate.   blocks[4] is the upper diagonal block describing the flow of mass from cell k to k+1 (for phases    with positive rate only).  \nboundary_flux::BoundaryFluxTupleType: A named tuple structure such that        - boundary_flux.lower.in: describes flow of density into lower boundary       - boundary_flux.lower.out: describes flow of density out of lower boundary       - boundary_flux.upper.in: describes flow of density into upper boundary       - boundary_flux.upper.out: describes flow of density out of upper boundary\nD::Union{Array{Float64, 2}, LinearAlgebra.Diagonal{Bool, Array{Bool, 1}}}: An array describing    how the flow of density changes when the phase process jumps between phases with different memberships.   This is the identity for FV and DG schemes. \n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.MatrixExponential","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.MatrixExponential","text":"MatrixExponential constructor method\n\nMatrixExponential(\n    a::Array{Float64,2},\n    S::Array{Float64,2},\n    s::Array{Float64,1},\n    D::Array{Float64}=[0],\n)\n\nInputs: \n\na a 1 by p Array of reals\nS a p by p Array of reals\ns a p by 1 Array of reals\nD an optional argument, if empty then me.D is the identity,   else is a p by p matrix\n\nThrows an error if the dimensions are inconsistent.\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.Mesh","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.Mesh","text":"Mesh\n\nAbstract type representing a discretisation mesh for a numerical scheme. \n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.Phase","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.Phase","text":"Phase\n\nRepresents a phase of the fluid queue.\n\nArguments:\n\nc::Float64: the rate of change of the fluid X(t) associated with the phase\nm::Int64: either -1 or 1, membership of the phase with either the set of positive or negative phases.   Default is positive, i.e. 1. Only relevant for FRAPApproximation.\nlpm::Bool: whether the phase has a point mass at the left/lower boundary\nrpm::Bool: whether the phase has a point mass at the right/upper boundary\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.PhaseSet","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.PhaseSet","text":"const PhaseSet = Array{Phase,1}\n\nA container for phases.\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.PhaseSet-Tuple{Vector{Float64}, Vector{Int64}, BitArray, BitArray}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.PhaseSet","text":"PhaseSet(c::Array{Float64, 1}[, m::Array{Int, 1}, lpm::BitArray, rpm::BitArray])\n\nConstruct an Array of phases.\n\nArguments:\n\nc: Array of rates\nm: (optional) array of memberships, see Phase()\nlpm: (optional) array of left point mass indicators, see Phase()\nrpm: (optional) array of right point mass indicators, see Phase()\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.SFMDistribution","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution{T <: Mesh} <: AbstractArray{Float64, 2}\n\nRepresentation of the distribution of a DiscretisedFluidQueue. \n\nThe field coeffs is a row-vector and indexing a distribution indexes this field. Similarly,  arithmetic operations on a distribution act on this vector.\n\nArguments:\n\ncoeffs::Array{Float64, 2}: A row vector of coefficients which encode the distribution of a    DiscretisedFluidQueue and can be used to reconstruct a solution.\ndq::DiscretisedFluidQueue{T}: \n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.SFMDistribution","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution(pdf::Function, dq::DiscretisedFluidQueue{FVMesh}, fun_evals::Int = 6)\n\nConstruct an approximation to pdf as the average of pdf of each cell. \n\nUses quadrature with fun_evals function evaluations to approximate cell averages.\n\n\n\n\n\n","category":"type"},{"location":"#DiscretisedFluidQueues.SFMDistribution-Tuple{Function, DiscretisedFluidQueue{DGMesh}}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution(pdf::Function, dq::DiscretisedFluidQueue{DGMesh})\n\nApproximates pdf via polynomials. \n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.SFMDistribution-Tuple{Function, DiscretisedFluidQueue{FRAPMesh}}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution(pdf::Function, dq::DiscretisedFluidQueue{FRAPMesh}; fun_evals = 100)\n\nReturn the appropriate initial condition to approximate the initial distribution pdf for the numerical discretisation scheme defined by the dq DiscretisedFluidQueue.\n\ni.e. for each cell compute the expected orbit position  pdf(xi)  a(x) dx where the integral is over each cell and  a(x) = a exp(S(x-yₖ))  if the membership of i is -1 and  a(x) = a exp(S(yₖ₁-x))  if the membership of i is 1 where  yₖ and yₖ₊₁ are the left and right cell edges, respectively, and  a and S are defined by dq.mesh.me are parameters of a MatrixExponential.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.SFMDistribution-Tuple{Function, DiscretisedFluidQueue{var\"#s40\"} where var\"#s40\"<:Mesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution(pdf::Function, dq::DiscretisedFluidQueue{<:Mesh}, fun_evals::Int = 6)\n\nReturn a discretised version of the pdf. The method of discretisation depends on the discretisation method  of dq.\n\nArguments:\n\npdf::Function: a function f(x::Float64,i::Int) where f(x,i)dx=P(X(0)∈dx,φ(0)=i) is the initial    distribution of a fluid queue.\ndqDiscretisedFluidQueue{<:Mesh}: \nfun_evals: the number of function evaluations used to approximate f(x,i)\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.SFMDistribution-Union{Tuple{DiscretisedFluidQueue{T}}, Tuple{T}} where T","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution(dq::DiscretisedFluidQueue{T})\n\nA blank initialiser for a fluid queue distribution a distribution with coeffs=zeros.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.Simulation","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.Simulation","text":"Simulation\n\nA container to hold simulations. \n\nAll arguments are arrays of the same ength + a model from which the simulations came\n\nArguments:\n\nt::Array{Float64, 1}: \nφ::Array{Int, 1}: \nX::Array{Float64, 1}: \nn::Array{Int, 1}: \nmodel::Model: \n\n\n\n\n\n","category":"type"},{"location":"#Base.size-Tuple{LazyGenerator}","page":"DiscretisedFluidQueues","title":"Base.size","text":"size(B::LazyGenerator)\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.UpdateXt-Tuple{Model, NamedTuple, Real, Float64, Float64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.UpdateXt","text":"Returns X(t+S) = min(max(X(t) + cᵢS0)U) where U is some upper bound on the process.\n\nUpdateXt(\n    model::Model,\n    SFM0::NamedTuple,\n    S::Real,\n    lwr::Float64,\n    upr::Float64,\n)\n\nArguments\n\nmodel: a Model object\nSFM0::NamedTuple containing at least the keys :X giving the value of   X(t) at the current time, and :φ giving the value of   φ(t) at the current time.\nS::Real: an elapsed amount of time to evaluate X at, i.e. X(t+S).\nlwr::Float64: lower regulated boundary for the fluid level\nupr::Float64: upper regulated boundary for the fluid level\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues._model_dicts-Tuple{Model}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues._model_dicts","text":"_model_dicts(model::Model) \n\ninput: a Model object\n\noutputs:      - SDict: a dictionary with keys \"+\",\"-\",\"0\",\"bullet\"     and corresponding values findall(model.C .> 0), findall(model.C .< 0),     findall(model.C .== 0), findall(model.C .!= 0), respectively.      - TDict: a dictionary of submatrices of T with keys     \"ℓm\" with ℓm+-0bullet and corresponding values     model.T[S[ℓ],S[m]].\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues._sum_cells_left-Tuple{SFMDistribution, Int64, Int64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues._sum_cells_left","text":"_sum_cells_left(d::SFMDistribution, i::Int, cell_idx::Int, dq::DiscretisedFluidQueue)\n\nAdd up all the probability mass in phase i in the cells to the left of cell_idx.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.basis-Tuple{DGMesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.basis","text":"basis(mesh::DGMesh)\n\nReturns mesh.basis; either \"lagrange\" or \"legendre\"\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.basis-Tuple{FRAPMesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.basis","text":"basis(mesh::FRAPMesh)\n\nConstant \"\"\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.basis-Tuple{FVMesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.basis","text":"basis(mesh::FVMesh)\n\nConstant \"\"\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.gauss_lobatto_points-Tuple{Float64, Float64, Int64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.gauss_lobatto_points","text":"gauss_lobatto_points(a::Float64, b::Float64, n_evals::Int)\n\nReturn array containing n_evals gauss lobatto points in the interval [a,b].\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.gauss_lobatto_quadrature-Tuple{Function, Float64, Float64, Int64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.gauss_lobatto_quadrature","text":"gauss_lobatto_quadrature(fun::Function, a::Float64, b::Float64, n_evals::Int)\n\nCompute a quadrature approximation of fun on the interval [a,b] with n_evals function  evaluations using the gauss_lobatto_points\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.gauss_lobatto_weights-Tuple{Float64, Float64, Int64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.gauss_lobatto_weights","text":"gauss_lobatto_weights(a::Float64, b::Float64, n_evals::Int)\n\nReturn array containing n_evals weights of the polynomials associated with the gauss lobatto points in the interval [a,b]. i.e. the itegrals over the interval [a,b]  of the lagrange polynomials defined by the nodes given by nodes = gauss_lobatto_points(a,b,n_evals)\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.lagrange_interpolation-Tuple{Function, Float64, Float64, Int64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.lagrange_interpolation","text":"lagrange_interpolation(fun::Function, a::Float64, b::Float64, n_evals::Int)\n\nReturn a polynomial approximation to fun of order n_evals-1 on the interval [a,b] using  the gauss_lobatto_points as the nodes of the lagrange polynomials.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.lagrange_polynomials-Tuple{Vector{Float64}, Float64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.lagrange_polynomials","text":"lagrange_polynomials(nodes::Array{Float64, 1}, evalPt::Float64)\n\nEvaluate the lagrange polynomials defied by nodes at the point evalPt.\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.local_dg_operators-Tuple{DGMesh}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.local_dg_operators","text":"local_dg_operators(mesh::DGMesh; v::Bool = false)\n\nConstruct the block matrices and vectors which define the discretised generator (i.e. the blocks, and boundary_flux in LazyGenerator).\n\n\n\n\n\n","category":"method"},{"location":"#DiscretisedFluidQueues.vandermonde-Tuple{Int64}","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues.vandermonde","text":"Construct a generalised vandermonde matrix.\n\nvandermonde( nBases::Int)\n\nNote: requires Jacobi package Pkg.add(\"Jacobi\")\n\nArguments\n\nnBases::Int: the degree of the basis\n\nOutput\n\na tuple with keys\n:V::Array{Float64,2}: where :V[:,i] contains the values of the ith   legendre polynomial evaluate at the GLL nodes.\n:inv: the inverse of :V\n:D::Array{Float64,2}: where V.D[:,i] contains the values of the derivative   of the ith legendre polynomial evaluate at the GLL nodes.\n\n\n\n\n\n","category":"method"}]
}
