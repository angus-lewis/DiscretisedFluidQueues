var documenterSearchIndex = {"docs":
[{"location":"dist/#Distributions-1","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"dist/#Construction-1","page":"Distributions","title":"Construction","text":"","category":"section"},{"location":"dist/#","page":"Distributions","title":"Distributions","text":"SFMDistribution\ninterior_point_mass\nleft_point_mass\nright_point_mass","category":"page"},{"location":"dist/#DiscretisedFluidQueues.SFMDistribution","page":"Distributions","title":"DiscretisedFluidQueues.SFMDistribution","text":"SFMDistribution{T <: Mesh}\n\nRepresentation of the distribution of a DiscretisedFluidQueue. \n\nThe field coeffs is a row-vector and indexing a distribution indexes this field. Similarly,  arithmetic operations on a distribution act on this vector.\n\nArguments:\n\ncoeffs::Array{Float64, 2}: A row vector of coefficients which encode the distribution of a    DiscretisedFluidQueue and can be used to reconstruct a solution.\ndq::DiscretisedFluidQueue{T}: \n\n\n\n\n\n","category":"type"},{"location":"dist/#DiscretisedFluidQueues.interior_point_mass","page":"Distributions","title":"DiscretisedFluidQueues.interior_point_mass","text":"interior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{<:Mesh})\n\nConstruct an approximation to a distribution of fluid queue with a point mass at (x,i).  Returns a SFMDistribution. The method of approximation is defined by the type of <:Mesh.\n\nArguments:\n\nx::Float64: The position of the point mass\ni::Int: The phase of the point mass\ndq::DiscretisedFluidQueue: \n\n\n\n\n\ninterior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{DGMesh{T}})\n\nConstructs a polynomial approximation to the point mass at (x,i)\n\n\n\n\n\ninterior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{FVMesh})\n\nConstruct an approximation to a point mass at (x,i). Basically, just puts mass 1 in the cell containing (x,i).\n\n\n\n\n\ninterior_point_mass(x::Float64, i::Int, dq::DiscretisedFluidQueue{FRAPMesh})\n\nReturn the appropriate initial condition to approximate the initial distribution which  is a point mass at (x,i) for the numerical discretisation scheme defined by the  dq DiscretisedFluidQueue.\n\nSee here for more\n\n\n\n\n\n","category":"function"},{"location":"dist/#DiscretisedFluidQueues.left_point_mass","page":"Distributions","title":"DiscretisedFluidQueues.left_point_mass","text":"left_point_mass(i::Int, dq::DiscretisedFluidQueue)\n\nConstruct a SFMDistribution with a point mass at the left boundary of dq in phase i and 0 elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"dist/#DiscretisedFluidQueues.right_point_mass","page":"Distributions","title":"DiscretisedFluidQueues.right_point_mass","text":"right_point_mass(i::Int, dq::DiscretisedFluidQueue)\n\nConstruct a SFMDistribution with a point mass at the left boundary of dq in phase i and 0 elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"dist/#Reconstructing-solutions-1","page":"Distributions","title":"Reconstructing solutions","text":"","category":"section"},{"location":"dist/#","page":"Distributions","title":"Distributions","text":"pdf(d::SFMDistribution)\npdf(d::SFMDistribution, x, i) \ncdf(d::SFMDistribution)\ncdf(d::SFMDistribution, x, i) ","category":"page"},{"location":"dist/#DiscretisedFluidQueues.pdf-Tuple{SFMDistribution}","page":"Distributions","title":"DiscretisedFluidQueues.pdf","text":"pdf(d::SFMDistribution)\n\nReturn a function of two variables (x::Float64,i::Int) which is the  probability distribution function defined by d. Approximates the density function of  a fluid queue.\n\n\n\n\n\n","category":"method"},{"location":"dist/#DiscretisedFluidQueues.pdf-Tuple{SFMDistribution, Any, Any}","page":"Distributions","title":"DiscretisedFluidQueues.pdf","text":"pdf(d::SFMDistribution, x, i)\n\nEvaluate pdf(d::SFMDistribution) at (x,i).\n\n\n\n\n\n","category":"method"},{"location":"dist/#DiscretisedFluidQueues.cdf-Tuple{SFMDistribution}","page":"Distributions","title":"DiscretisedFluidQueues.cdf","text":"cdf(d::SFMDistribution)\n\nReturn a function of two variables (x::Real,i::Int) which is the  cumulative distribution distribution function defined by d. Approximates the distribution function of  a fluid queue.\n\n\n\n\n\n","category":"method"},{"location":"dist/#DiscretisedFluidQueues.cdf-Tuple{SFMDistribution, Any, Any}","page":"Distributions","title":"DiscretisedFluidQueues.cdf","text":"cdf(d::SFMDistribution, x, i)\n\nEvaluate cdf(d::SFMDistribution) at (x,i).\n\n\n\n\n\n","category":"method"},{"location":"mesh/#Mesh-(discretisation)-related-Types-1","page":"Mesh (Discretisations)","title":"Mesh (discretisation)-related Types","text":"","category":"section"},{"location":"mesh/#","page":"Mesh (Discretisations)","title":"Mesh (Discretisations)","text":"Mesh\nDGMesh\nFRAPMesh\nFVMesh","category":"page"},{"location":"mesh/#DiscretisedFluidQueues.Mesh","page":"Mesh (Discretisations)","title":"DiscretisedFluidQueues.Mesh","text":"Mesh\n\nAbstract type representing a discretisation mesh for a numerical scheme.  Possible subtypes are DGMesh, FRAPMesh, FVMesh\n\n\n\n\n\n","category":"type"},{"location":"mesh/#DiscretisedFluidQueues.DGMesh","page":"Mesh (Discretisations)","title":"DiscretisedFluidQueues.DGMesh","text":"DGMesh{T} <: Mesh{T}\n\nA structure representing a discretisation scheme to be used for a DiscretisedFluidQueue. \n\nArguments:\n\nnodes::AbstractArray{Float64, 1}: The edges of the cells.\nn_bases::Int: The number of basis functions used to represent the solution on each cell\n\n\n\n\n\n","category":"type"},{"location":"mesh/#DiscretisedFluidQueues.FRAPMesh","page":"Mesh (Discretisations)","title":"DiscretisedFluidQueues.FRAPMesh","text":"FRAPMesh{T} <: Mesh{T}\n\nA QBD-RAP discretisation scheme for a DiscretisedFluidQueue. \n\nArguments\n\nnodes: the cell edges\nme: the MatrixExponential used to approximate model the fluid queue on each cell.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#DiscretisedFluidQueues.FVMesh","page":"Mesh (Discretisations)","title":"DiscretisedFluidQueues.FVMesh","text":"FVMesh{T} <: Mesh{T}\n\nA finite volume discretisation scheme for a DiscretisedFluidQueue. \n\nArguments\n\nnodes: the cell edges (the nodes are at the center of the cell)\norder: the order of the polynomial interpolation used to approximate the flux at the \n\ncell edges.\n\n\n\n\n\n","category":"type"},{"location":"mesh/#Mesh-(discretisation)-related-Methods-1","page":"Mesh (Discretisations)","title":"Mesh (discretisation)-related Methods","text":"","category":"section"},{"location":"mesh/#","page":"Mesh (Discretisations)","title":"Mesh (Discretisations)","text":"cell_nodes\nn_intervals\nΔ\nn_bases_per_phase\nn_bases_per_cell\ntotal_n_bases","category":"page"},{"location":"mesh/#DiscretisedFluidQueues.cell_nodes","page":"Mesh (Discretisations)","title":"DiscretisedFluidQueues.cell_nodes","text":"cell_nodes(mesh::DGMesh)\n\nThe positions of the GLJ nodes within each cell of a mesh.\n\n\n\n\n\ncell_nodes(mesh::FVMesh)\n\nThe cell centres\n\n\n\n\n\ncell_nodes(mesh::FRAPMesh)\n\nThe cell centre\n\n\n\n\n\n","category":"function"},{"location":"mesh/#DiscretisedFluidQueues.n_intervals","page":"Mesh (Discretisations)","title":"DiscretisedFluidQueues.n_intervals","text":"n_intervals(m)\n\nTotal number of cells for a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#DiscretisedFluidQueues.Δ","page":"Mesh (Discretisations)","title":"DiscretisedFluidQueues.Δ","text":"Δ(m)\n\nThe width of each cell for a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\nΔ(m,k::Int)\n\nThe width of cell k for a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#DiscretisedFluidQueues.n_bases_per_phase","page":"Mesh (Discretisations)","title":"DiscretisedFluidQueues.n_bases_per_phase","text":"n_bases_per_phase(m)\n\nTotal number of basis functions used to represent the fluid queue for each phase      of a Mesh or DiscretisedFluidQueue.\n\n\n\n\n\n","category":"function"},{"location":"mesh/#DiscretisedFluidQueues.n_bases_per_cell","page":"Mesh (Discretisations)","title":"DiscretisedFluidQueues.n_bases_per_cell","text":"n_bases_per_cell(m) =\n\nReturn the number of basis functions on each cell of a given DiscretisedFluidQueue or Mesh.\n\n\n\n\n\nn_bases_per_cell(mesh::DGMesh)\n\nNumber of bases in a cell\n\n\n\n\n\nn_bases_per_cell(mesh::FVMesh)\n\nConstant=1\n\n\n\n\n\nn_bases_per_cell(mesh::FRAPMesh)\n\nNumber of bases in a cell\n\n\n\n\n\n","category":"function"},{"location":"mesh/#DiscretisedFluidQueues.total_n_bases","page":"Mesh (Discretisations)","title":"DiscretisedFluidQueues.total_n_bases","text":"total_n_bases(m)\n\nReturn the number of basis functions of a given DiscretisedFluidQueue or Mesh.\n\n\n\n\n\n","category":"function"},{"location":"models/#Models-and-Discretisations-1","page":"Models","title":"Models and Discretisations","text":"","category":"section"},{"location":"models/#Model-related-Types-1","page":"Models","title":"Model-related Types","text":"","category":"section"},{"location":"models/#","page":"Models","title":"Models","text":"Phase\nPhaseSet\nModel\nDiscretisedFluidQueue\nBoundedFluidQueue ","category":"page"},{"location":"models/#DiscretisedFluidQueues.Phase","page":"Models","title":"DiscretisedFluidQueues.Phase","text":"Phase\n\nRepresents a phase of the fluid queue.\n\nArguments:\n\nc::Float64: the rate of change of the fluid X(t) associated with the phase\nm::Int64: either -1 or 1, membership of the phase with either the set of positive or negative phases.   Default is positive, i.e. 1. Only relevant for FRAPApproximation.\nlpm::Bool: whether the phase has a point mass at the left/lower boundary\nrpm::Bool: whether the phase has a point mass at the right/upper boundary\n\n\n\n\n\n","category":"type"},{"location":"models/#DiscretisedFluidQueues.PhaseSet","page":"Models","title":"DiscretisedFluidQueues.PhaseSet","text":"const PhaseSet = Array{Phase,1}\n\nA container for phases.\n\n\n\n\n\n","category":"type"},{"location":"models/#DiscretisedFluidQueues.Model","page":"Models","title":"DiscretisedFluidQueues.Model","text":"Model\n\nAbstract type represnting a BoundedFluidQueue or DiscretisedFluidQueue\n\n\n\n\n\n","category":"type"},{"location":"models/#DiscretisedFluidQueues.DiscretisedFluidQueue","page":"Models","title":"DiscretisedFluidQueues.DiscretisedFluidQueue","text":"DiscretisedFluidQueue{T <: Mesh}\n\nA container to hold a BoundedFluidQueue and a discretisation scheme (a mesh).  Parametric type depending on the type of discretisation scheme (<:Mesh)\n\nArguments:\n\nmodel::Model: a BoundedFluidQueue\nmesh::T: either a DGMesh, FVMesh or FRAPMesh specifying the discretisation scheme for the    continuous level of the fluid queue, X(t). \n\n\n\n\n\n","category":"type"},{"location":"models/#DiscretisedFluidQueues.BoundedFluidQueue","page":"Models","title":"DiscretisedFluidQueues.BoundedFluidQueue","text":"BoundedFluidQueue <: Model\n\nConstructor for a fluid queue model. \n\nArguments:\n\nT::Array{Float64, 2}: Generator of the phase process\nS::PhaseSet: An array of phases describing the evolution of the fluid level in each phase.\nP_lwr::Array{Float64,2}: Probabilities of phase change upon hitting the lower boundary.    A |S₋| by |S| array.\nP_upr::Array{Float64,2}: Probabilities of phase change upon hitting the upper boundary.    A |S₊| by |S| array.\nb::Float64: the upper boundary of the fluid level (the lower boundary is 0 by default).\n\n\n\n\n\n","category":"type"},{"location":"models/#Model-related-Methods-1","page":"Models","title":"Model-related Methods","text":"","category":"section"},{"location":"models/#","page":"Models","title":"Models","text":"n_phases\nrates\nmembership\nN₋\nN₊\naugment_model","category":"page"},{"location":"models/#DiscretisedFluidQueues.n_phases","page":"Models","title":"DiscretisedFluidQueues.n_phases","text":"n_phases(S::PhaseSet)\n\nReturn the number of phases from a PhaseSet, BoundedFluidQueue, or DiscretisedFluidQueue\n\n\n\n\n\n","category":"function"},{"location":"models/#DiscretisedFluidQueues.rates","page":"Models","title":"DiscretisedFluidQueues.rates","text":"rates(S::PhaseSet, i::Int)\n\nReturn the rate of the phase from a PhaseSet, BoundedFluidQueue, or DiscretisedFluidQueue\n\n\n\n\n\n","category":"function"},{"location":"models/#DiscretisedFluidQueues.membership","page":"Models","title":"DiscretisedFluidQueues.membership","text":"membership(S::PhaseSet, i::Int)\n\nReturn the membership of phases from a PhaseSet\n\n\n\n\n\n","category":"function"},{"location":"models/#DiscretisedFluidQueues.N₋","page":"Models","title":"DiscretisedFluidQueues.N₋","text":"N₋(S::PhaseSet)\n\nReturn the number of left/lower point masses of a PhaseSet, BoundedFluidQueue or DiscretisedFluidQueue\n\n\n\n\n\n","category":"function"},{"location":"models/#DiscretisedFluidQueues.N₊","page":"Models","title":"DiscretisedFluidQueues.N₊","text":"N₊(S::PhaseSet) = begin\n\nReturn the number of right/upper point masses of a PhaseSet, BoundedFluidQueue or DiscretisedFluidQueue\n\n\n\n\n\n","category":"function"},{"location":"models/#DiscretisedFluidQueues.augment_model","page":"Models","title":"DiscretisedFluidQueues.augment_model","text":"augment_model(model::Model)\n\nGiven a BoundedFluidQueue, return a BoundedFluidQueue with twice as many phases with rate 0, one set associated  with m=1 phases and one associated with m=-1 phases. \n\n\n\n\n\n","category":"function"},{"location":"examples/#Reflecting-boundaries-1","page":"Examples","title":"Reflecting boundaries","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Create a model with (for example)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"T = [-2.5 2 0.5; 1 -2 1; 1 2 -3] # generator of the phase\nC = [0.0; 2.0; -3.0]    # rates dX/dt\nb = 10.0 # upper boundary of fluid queue\nP_lwr = [0.0 1.0 0.0] # transition probabilities upon hitting lower boundary\nP_upr = [0.0 0.0 1.0] # transition probabilities upon hitting upper boundary\n\nS = PhaseSet(C) \nmodel = BoundedFluidQueue(T,S,P_lwr,P_upr,b) \n\n# Create a discretisation mesh (a grid + method with which to approximate the solution) \nnodes = 0.0:1.0:model.b\norder = 3\nmesh = FRAPMesh(nodes,order)\n\n# Combine the model and the discretisation scheme (mesh) to form a discretised fluid queue\ndq = DiscretisedFluidQueue(model,mesh)\n\nB = build_full_generator(dq)\n\n# initial distribution \nf(x,i) = (i-1)/model.b./sum((1:3).-1) # the initial distribution\nd = SFMDistribution(f,dq)\n\n# Integrate over time with \nt = 3.2\ndt = integrate_time(d,B,t,StableRK4(0.01))\n\nu = pdf(dt)\n\n# Evaluate solution as a function \nu(0.1,1) # = P(X(3.2)<0.1, phi(3.2)=1)","category":"page"},{"location":"examples/#Slope-limited-DG-scheme-and-point-mass-initial-conditions-1","page":"Examples","title":"Slope limited DG scheme and point mass initial conditions","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Create a model with (for example)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"# Create a discretisation mesh (a grid + method with which to approximate the solution) \nnodes = 0.0:1.0:model.b\norder = 3\nmesh = DGMesh(nodes,order)\n\n# Combine the model and the discretisation scheme (mesh) to form a discretised fluid queue\ndq = DiscretisedFluidQueue(model,mesh)\n\nB = build_full_generator(dq)\n\n# initial distribution \nd = interior_point_mass(eps(),1,dq) # point mass at x=eps() in phase=1\n\n# Integrate over time with \ndt = integrate_time(d,B,t,StableRK4(0.01);limiter=GeneralisedMUSCL)\n\nu = cdf(dt)\n\n# Evaluate solution as a function \nu(0.1,1) # = P(X(3.2)<0.1, phi(3.2)=1)","category":"page"},{"location":"examples/#Simulate-1","page":"Examples","title":"Simulate","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Create a model with (for example)","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"n_sim = 10_000\nsims = simulate(model,fixed_time(t),(X=fill(eps(),n_sim), φ=ones(Int,n_sim)))\n\nu = cdf(sims)\n\n# Evaluate solution as a function \nu(0.1,1) # = P(X(3.2)<0.1, phi(3.2)=1)","category":"page"},{"location":"poly/#Polynomial-interpolation-and-tools-1","page":"Polynomial tools","title":"Polynomial interpolation and tools","text":"","category":"section"},{"location":"poly/#","page":"Polynomial tools","title":"Polynomial tools","text":"DG and FV methods rely on polynomial approximations. ","category":"page"},{"location":"poly/#","page":"Polynomial tools","title":"Polynomial tools","text":"DiscretisedFluidQueues.lagrange_polynomials\nDiscretisedFluidQueues.gauss_lobatto_points\nDiscretisedFluidQueues.gauss_lobatto_weights\nDiscretisedFluidQueues.lagrange_interpolation\nDiscretisedFluidQueues.gauss_lobatto_quadrature\nDiscretisedFluidQueues.vandermonde","category":"page"},{"location":"poly/#DiscretisedFluidQueues.lagrange_polynomials","page":"Polynomial tools","title":"DiscretisedFluidQueues.lagrange_polynomials","text":"lagrange_polynomials(nodes::Array{Float64, 1}, evalPt::Float64)\n\nEvaluate the lagrange interpolating polynomials defied by nodes at the point evalPt.\n\n\n\n\n\n","category":"function"},{"location":"poly/#DiscretisedFluidQueues.gauss_lobatto_points","page":"Polynomial tools","title":"DiscretisedFluidQueues.gauss_lobatto_points","text":"gauss_lobatto_points(a::Float64, b::Float64, n_evals::Int)\n\nReturn array containing n_evals gauss lobatto points in the interval [a,b].\n\n\n\n\n\n","category":"function"},{"location":"poly/#DiscretisedFluidQueues.gauss_lobatto_weights","page":"Polynomial tools","title":"DiscretisedFluidQueues.gauss_lobatto_weights","text":"gauss_lobatto_weights(a::Float64, b::Float64, n_evals::Int)\n\nReturn array containing n_evals weights of the polynomials associated with the gauss lobatto points in the interval [a,b]. i.e. the itegrals over the interval [a,b]  of the lagrange polynomials defined by the nodes given by nodes = gauss_lobatto_points(a,b,n_evals)\n\n\n\n\n\n","category":"function"},{"location":"poly/#DiscretisedFluidQueues.lagrange_interpolation","page":"Polynomial tools","title":"DiscretisedFluidQueues.lagrange_interpolation","text":"lagrange_interpolation(fun::Function, a::Float64, b::Float64, n_evals::Int)\n\nReturn a polynomial approximation to fun of order n_evals-1 on the interval [a,b] using  the gauss_lobatto_points as the nodes of the lagrange polynomials.\n\n\n\n\n\n","category":"function"},{"location":"poly/#DiscretisedFluidQueues.gauss_lobatto_quadrature","page":"Polynomial tools","title":"DiscretisedFluidQueues.gauss_lobatto_quadrature","text":"gauss_lobatto_quadrature(fun::Function, a::Float64, b::Float64, n_evals::Int)\n\nCompute a quadrature approximation of fun on the interval [a,b] with n_evals function  evaluations using the gauss_lobatto_points\n\n\n\n\n\ngauss_lobatto_quadrature(fun::Function, nodes::Array{Float64,1})\n\nCompute a quadrature approximation of fun on the interval nodes[1] to nodes[end] evaluating the function fun at nodes\n\n\n\n\n\n","category":"function"},{"location":"poly/#DiscretisedFluidQueues.vandermonde","page":"Polynomial tools","title":"DiscretisedFluidQueues.vandermonde","text":"Construct a generalised vandermonde matrix.\n\nvandermonde( nBases::Int)\n\nNote: requires Jacobi package Pkg.add(\"Jacobi\")\n\nArguments\n\nnBases::Int: the degree of the basis\n\nOutput\n\na tuple with keys\n:V::Array{Float64,2}: where :V[:,i] contains the values of the ith   legendre polynomial evaluate at the GLL nodes.\n:inv: the inverse of :V\n:D::Array{Float64,2}: where V.D[:,i] contains the values of the derivative   of the ith legendre polynomial evaluate at the GLL nodes.\n\n\n\n\n\n","category":"function"},{"location":"generators/#Generators-1","page":"Generators","title":"Generators","text":"","category":"section"},{"location":"generators/#","page":"Generators","title":"Generators","text":"Generator\nLazyGenerator\nFullGenerator\nbuild_lazy_generator\nbuild_full_generator\nstatic_generator\nsize","category":"page"},{"location":"generators/#DiscretisedFluidQueues.Generator","page":"Generators","title":"DiscretisedFluidQueues.Generator","text":"Generator\n\nAbstract type representing a discretised infinitesimal generator of a FLuidQueue.  Behaves much like a square matrix. \n\n\n\n\n\n","category":"type"},{"location":"generators/#DiscretisedFluidQueues.LazyGenerator","page":"Generators","title":"DiscretisedFluidQueues.LazyGenerator","text":"LazyGenerator{<:Mesh} <: Generator{<:Mesh}\n\nA lazy representation of a block matrix with is a generator of a DiscretisedFluidQueue.\n\nLower memory requirements than FullGenerator but aritmetic operations and indexing may be slower.\n\nArguments:\n\ndq::DiscretisedFluidQueue: \nblocks::Tuple{Array{Float64, 2}, Array{Float64, 2}, Array{Float64, 2}, Array{Float64, 2}}:    Block matrices describing the flow of mass within and between cells. blocks[1] is the lower    diagonal block describing the flow of mass from cell k+1 to cell (k for phases    with negative rate only). blocks[2] (blocks[3]) is the    diagonal block describing the flow of mass within a cell for a phase with positive (negative) rate.   blocks[4] is the upper diagonal block describing the flow of mass from cell k to k+1 (for phases    with positive rate only).  \nboundary_flux::BoundaryFlux: A named tuple structure such that        - boundary_flux.lower.in: describes flow of density into lower boundary       - boundary_flux.lower.out: describes flow of density out of lower boundary       - boundary_flux.upper.in: describes flow of density into upper boundary       - boundary_flux.upper.out: describes flow of density out of upper boundary\nD::Union{Array{Float64, 2}, LinearAlgebra.Diagonal{Bool, Array{Bool, 1}}}: An array describing    how the flow of density changes when the phase process jumps between phases with different memberships.   This is the identity for FV and DG schemes. \n\n\n\n\n\n","category":"type"},{"location":"generators/#DiscretisedFluidQueues.FullGenerator","page":"Generators","title":"DiscretisedFluidQueues.FullGenerator","text":"FullGenerator{T} <: Generator{T}\n\nAn Matrix or SparseMatrixCSC representation of the generator of a generator of a DiscretisedFluidQueue.\n\nHigher memory requirements than LazyGenerator (as blocks are duplicated) but much faster matrix arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"generators/#DiscretisedFluidQueues.build_lazy_generator","page":"Generators","title":"DiscretisedFluidQueues.build_lazy_generator","text":"build_lazy_generator(dq::DiscretisedFluidQueue; v::Bool = false)\n\nBuild a lazy representation of the generator of a discretised fluid queue.\n\n\n\n\n\n","category":"function"},{"location":"generators/#DiscretisedFluidQueues.build_full_generator","page":"Generators","title":"DiscretisedFluidQueues.build_full_generator","text":"build_full_generator(dq::DiscretisedFluidQueue; v::Bool = false)\n\nReturns a SparseMatrixCSC generator of a DiscretisedFluidQueue.\n\n\n\n\n\nbuild_full_generator(lzB::LazyGenerator)\n\nReturns a SparseMatrixCSC representation of a LazyGenerator.\n\n\n\n\n\n","category":"function"},{"location":"generators/#DiscretisedFluidQueues.static_generator","page":"Generators","title":"DiscretisedFluidQueues.static_generator","text":"(Experimantal) convert the block matrices of the lazy generator to static arrays\n\n\n\n\n\n","category":"function"},{"location":"generators/#Base.size","page":"Generators","title":"Base.size","text":"size(B::LazyGenerator)\n\n\n\n\n\n","category":"function"},{"location":"sim/#Simulate-1","page":"Simulate","title":"Simulate","text":"","category":"section"},{"location":"sim/#","page":"Simulate","title":"Simulate","text":"Tools to simulate a BoundedFluidQueue. ","category":"page"},{"location":"sim/#Simulate-and-evaluate-simulations-1","page":"Simulate","title":"Simulate and evaluate simulations","text":"","category":"section"},{"location":"sim/#","page":"Simulate","title":"Simulate","text":"Simulation\nsimulate\ncdf(s::Simulation)","category":"page"},{"location":"sim/#DiscretisedFluidQueues.Simulation","page":"Simulate","title":"DiscretisedFluidQueues.Simulation","text":"Simulation\n\nA container to hold simulations. \n\nAll arguments are arrays of the same ength + a model from which the simulations came\n\nArguments:\n\nt::Array{Float64, 1}: \nφ::Array{Int, 1}: \nX::Array{Float64, 1}: \nn::Array{Int, 1}: \nmodel::Model: \n\n\n\n\n\n","category":"type"},{"location":"sim/#DiscretisedFluidQueues.simulate","page":"Simulate","title":"DiscretisedFluidQueues.simulate","text":"Simulates a SFM defined by Model until the StoppingTime has occured, given the InitialCondition on (φ(0),X(0)).\n\nsimulate(\n    model::Model,\n    StoppingTime::Function,\n    InitCondition::NamedTuple{(:φ, :X)},\n)\n\nArguments\n\nmodel: A Model object \nStoppingTime: A function which takes the value of the process at the current   time and at the time of the last jump of the phase process, as well as the   model object.   i.e. StoppingTime(;model,SFM,SFM0,lwer,upr) where SFM and SFM0 are tuples with   keys (:t::Float64, :φ::Int, :X::Float64, :n::Int) which are the value of   the SFM at the current time, and time of the previous jump of the phase   process, repsectively. The StoppingTime must return a   NamedTuple{(:Ind, :SFM)} type where :Ind is a :Bool value stating   whether the stopping time has occured or not and :SFM is a tuple in the   same form as the input SFM but which contains the value of the SFM at   the stopping time.\nInitCondition: NamedTuple with keys (:φ, :X), InitCondition.φ is a   vector of length M of initial states for the phase, and InitCondition.X   is a vector of length M of initial states for the level. M is the number   of simulations to be done.\n\nOutput\n\nA Simulation object.\n\n\n\n\n\n","category":"function"},{"location":"sim/#DiscretisedFluidQueues.cdf-Tuple{Simulation}","page":"Simulate","title":"DiscretisedFluidQueues.cdf","text":"cdf(s::Simulation)\n\nReturn a empirical cdf of the fluid queue given a simulation. \n\nOutput is a function of two variables (x,i) and gives the empirical distribution      function P(X(τ)xφ(τ)=i)\n\n\n\n\n\n","category":"method"},{"location":"sim/#","page":"Simulate","title":"Simulate","text":"","category":"page"},{"location":"sim/#Predefined-stopping-times-1","page":"Simulate","title":"Predefined stopping times","text":"","category":"section"},{"location":"sim/#","page":"Simulate","title":"Simulate","text":"fixed_time\nn_jumps\nfirst_exit_x","category":"page"},{"location":"sim/#DiscretisedFluidQueues.fixed_time","page":"Simulate","title":"DiscretisedFluidQueues.fixed_time","text":"Constructs the StoppingTime 1(tT)\n\nfixed_time( T::Real)\n\nArguments\n\nT: a time at which to stop the process\n\nOutput\n\nfixed_timeFun: a function with one methods\n`fixed_timeFun(   model::Model,   SFM::NamedTuple{(:t, :φ, :X, :n)},   SFM0::NamedTuple{(:t, :φ, :X, :n)},\n)`: a stopping time for a SFM.\n\n\n\n\n\n","category":"function"},{"location":"sim/#DiscretisedFluidQueues.n_jumps","page":"Simulate","title":"DiscretisedFluidQueues.n_jumps","text":"Constructs the StoppingTime 1(N(t)n) where N(t) is the number of jumps of φ by time t.\n\nn_jumps( N::Int)\n\nArguments\n\nN: a desired number of jumps\n\nOutput\n\nn_jumpsFun: a function with one methods\n`n_jumpsFun(   model::Model,   SFM::NamedTuple{(:t, :φ, :X, :n)},   SFM0::NamedTuple{(:t, :φ, :X, :n)},\n)`: a stopping time for a SFM.\n\n\n\n\n\n","category":"function"},{"location":"sim/#DiscretisedFluidQueues.first_exit_x","page":"Simulate","title":"DiscretisedFluidQueues.first_exit_x","text":"Constructs the StoppingTime which is the first exit of the process X(t) from the interval uv.\n\nfirst_exit_x( u::Real, v::Real)\n\nArguments\n\nu: a lower boundary\nv: an upper boundary\n\nOutput\n\nfirst_exit_xFun: a function with one methods\n`firstexitxFun(   model::Model,   SFM::NamedTuple{(:t, :φ, :X, :n)},   SFM0::NamedTuple{(:t, :φ, :X, :n)},\n)`: a stopping time for a SFM.\n\n\n\n\n\n","category":"function"},{"location":"#DiscretisedFluidQueues-1","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"","category":"section"},{"location":"#Numerical-approximation-schemes-for-stochastic-fluid-queues.-1","page":"DiscretisedFluidQueues","title":"Numerical approximation schemes for stochastic fluid queues.","text":"","category":"section"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"The evolution of a stochastic fluid queue with generator T_ij_ijin S and associated diagonal matrix of rates C = diag(c_iiin S) can be described by the PDE (when it exists)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"cfracpartialpartial t  mathbf f(xit) =  mathbf f(xit) T - cfracpartialpartial x  mathbf f(xit) C","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"where mathbf f(xit) dx = (f(xit))_iin S = (P(X(t)in dx varphi(t)=i))_iin S the time-dependent joint density/mass function. ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"This package implements finite element and finite volume numerical solvers to approximate the right-hand side of this PDE; ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Discontinuous Galerkin: projects the right-hand side of the PDE on to a basis of polynomials,\nFinite volume:\nQBD-RAP approximation: use matrix-exponential distributions to model the solution locally on each cell.","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"","category":"page"},{"location":"#Usage-1","page":"DiscretisedFluidQueues","title":"Usage","text":"","category":"section"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"pkg> add https://github.com/angus-lewis/DiscretisedFluidQueues","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"julia> using DiscretisedFluidQueues","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Create a model with (for example)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"T = [-2.5 2 0.5; 1 -2 1; 1 2 -3] # generator of the phase\nC = [0.0; 2.0; -3.0]    # rates dX/dt\nb = 10.0 # upper boundary of fluid queue\n\nS = PhaseSet(C) \n\nmodel = BoundedFluidQueue(T,S,b) ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Create a discretisation mesh (a grid + method with which to approximate the solution) with any of (e.g.)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"nodes = 0.0:1.0:model.b\n\nnbases = 3\nmesh = DGMesh(nodes,nbases)\n\nfv_order = 3\nfvmesh = FVMesh(collect(nodes),fv_order)\n\norder = 3\nfrapmesh = FRAPMesh(nodes,order)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Combine the model and the discretisation scheme (mesh) to form a discretised fluid queue","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"dq = DiscretisedFluidQueue(model,mesh)\n# or dq = DiscretisedFluidQueue(model,fvmesh)\n# or dq = DiscretisedFluidQueue(model,frapmesh)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Construct an approximation to the generator with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"B = build_full_generator(dq)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"B is essentially a matrix which we can think of as describing the ODE","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"fracdd t   mathbf a(t) =   mathbf a(t) B","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"where $ \\mathbf a(t)$ is a row vector of coefficients and $  \\mathbf a(t)  \\mathbf u(x,i) \\approx  \\mathbf f(x,i,t)$ approximates the solution where $ \\mathbf u(x,i)$ is a column vector of functions defined by the discretisation scheme.","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Construct an initial distribution with (e.g.)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"f(x,i) = (i-1)/model.b./sum((1:3).-1) # the initial distribution\nd = SFMDistribution(f,dq)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Integrate over time with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"t = 3.2\ndt = integrate_time(d,B,t,StableRK4(0.01);limiter=NoLimiter) # no slope limiter","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Reconstruct approximate solution from coefficients with ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"u = pdf(dt)\n# or u = cdf(dt)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"Evaluate solution as a function ","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"u(0.1,1) # = P(X(3.2)<0.1, phi(3.2)=1)","category":"page"},{"location":"#","page":"DiscretisedFluidQueues","title":"DiscretisedFluidQueues","text":"This is my PhD topic; find the thesis here.","category":"page"},{"location":"me_tools/#ME-Tools-1","page":"ME Tools","title":"ME Tools","text":"","category":"section"},{"location":"me_tools/#Types-1","page":"ME Tools","title":"Types","text":"","category":"section"},{"location":"me_tools/#","page":"ME Tools","title":"ME Tools","text":"AbstractMatrixExponential\nConcentratedMatrixExponential\nMatrixExponential \ncme_params","category":"page"},{"location":"me_tools/#DiscretisedFluidQueues.AbstractMatrixExponential","page":"ME Tools","title":"DiscretisedFluidQueues.AbstractMatrixExponential","text":"AbstractMatrixExponential\n\n\n\n\n\n","category":"type"},{"location":"me_tools/#DiscretisedFluidQueues.ConcentratedMatrixExponential","page":"ME Tools","title":"DiscretisedFluidQueues.ConcentratedMatrixExponential","text":"Similar to MatrixExponential but has a neater implementation of orbit() due to nice structure.\n\n\n\n\n\n","category":"type"},{"location":"me_tools/#DiscretisedFluidQueues.MatrixExponential","page":"ME Tools","title":"DiscretisedFluidQueues.MatrixExponential","text":"MatrixExponential constructor method\n\nMatrixExponential(\n    a::Array{Float64,2},\n    S::Array{Float64,2},\n    s::Array{Float64,1},\n    D::Array{Float64}=[0],\n)\n\nInputs: \n\na a 1 by p Array of reals\nS a p by p Array of reals\ns a p by 1 Array of reals\nD an optional argument, if empty then me.D is the identity,   else is a p by p matrix\n\nThrows an error if the dimensions are inconsistent.\n\n\n\n\n\n","category":"type"},{"location":"me_tools/#DiscretisedFluidQueues.cme_params","page":"ME Tools","title":"DiscretisedFluidQueues.cme_params","text":"cme_params\n\nA Dict storing parameters of concentrated matrix exponential distributions. See https://github.com/ghorvath78/iltcme.\n\n\n\n\n\n","category":"constant"},{"location":"me_tools/#Methods-1","page":"ME Tools","title":"Methods","text":"","category":"section"},{"location":"me_tools/#","page":"ME Tools","title":"ME Tools","text":"build_me\npdf(a::Array{Float64,2}, me::AbstractMatrixExponential)\nccdf(a::Array{Float64,2}, me::AbstractMatrixExponential)\ncdf(a::Array{Float64,2}, me::AbstractMatrixExponential)","category":"page"},{"location":"me_tools/#DiscretisedFluidQueues.build_me","page":"ME Tools","title":"DiscretisedFluidQueues.build_me","text":"build_me(params; mean::Real = 1)\n\nReturn a ConcentratedMatrixExponential as defined by the dictionary params. i.e. see CMEParams[3] for an order 3 CME. \n\n\n\n\n\n","category":"function"},{"location":"me_tools/#DiscretisedFluidQueues.pdf-Tuple{Matrix{Float64}, AbstractMatrixExponential}","page":"ME Tools","title":"DiscretisedFluidQueues.pdf","text":"pdf([a::Array{Float64, 2},] me::AbstractMatrixExponential)\n\nReturn a the probability density function of a matrix exponential as a function.\n\nIf a is not specified then the initial vector of the me is me.a\n\nArguments:\n\na: a row vector with length size(me.S,1)\n\n\n\n\n\n","category":"method"},{"location":"me_tools/#DiscretisedFluidQueues.ccdf-Tuple{Matrix{Float64}, AbstractMatrixExponential}","page":"ME Tools","title":"DiscretisedFluidQueues.ccdf","text":"ccdf(a::Array{Float64, 2}, me::AbstractMatrixExponential)\n\nReturn a the complimentary cumulative distribution function (1-cdf) of a matrix exponential as a function.\n\nIf a is not specified then the initial vector of the me is me.a\n\nArguments:\n\na: a row vector with length size(me.S,1)\n\n\n\n\n\n","category":"method"},{"location":"me_tools/#DiscretisedFluidQueues.cdf-Tuple{Matrix{Float64}, AbstractMatrixExponential}","page":"ME Tools","title":"DiscretisedFluidQueues.cdf","text":"cdf(a::Array{Float64, 2}, me::AbstractMatrixExponential) = begin\n\nReturn a the cumulative distribution function of a matrix exponential as a function.\n\nIf a is not specified then the initial vector of the me is me.a\n\nArguments:\n\na: a row vector with length size(me.S,1)\n\n\n\n\n\n","category":"method"},{"location":"time_integration/#Integrate-time-1","page":"Time Integration","title":"Integrate time","text":"","category":"section"},{"location":"time_integration/#","page":"Time Integration","title":"Time Integration","text":"ExplicitRungeKuttaScheme\nForwardEuler\nHeuns\nStableRK3\nStableRK4\nintegrate_time","category":"page"},{"location":"time_integration/#DiscretisedFluidQueues.ExplicitRungeKuttaScheme","page":"Time Integration","title":"DiscretisedFluidQueues.ExplicitRungeKuttaScheme","text":"ExplicitRungeKuttaScheme(\n    step_size::Float64,\n    alpha::LinearAlgebra.LowerTriangular{Float64},\n    beta::LinearAlgebra.LowerTriangular{Float64},\n)\n\nGeneric data container for ExplicitRungeKuttaScheme for use in integrate_time.\n\nWe are interested in numerically integrating ODEs of the form     a(t) = a(t) Q\n\nwhere a(t) is a vector of coefficients and Q is a matrix, given an initial condition a(0). \n\nIn this context, Explicit Runge-Kutta methods with s stages can be written as \n\nv^(0) = a(t)\n\nv^(l) = sum_k=0^l-1 alpha_l k v^(k) + hbeta_l k  v^(k) Q l = 1s\n\na(t+h) =v^(s)\n\nwhere h is the step-size and alpha_l k and beta_l k are parameters which define the scheme. \n\nArguments\n\nstep_size::Float64: the step size of the integration scheme.\nalpha::LinearAlgebra.LowerTriangular{Float64}: coefficients as described above \nbeta::LinearAlgebra.LowerTriangular{Float64}: coefficients as described above \n\n\n\n\n\n","category":"type"},{"location":"time_integration/#DiscretisedFluidQueues.ForwardEuler","page":"Time Integration","title":"DiscretisedFluidQueues.ForwardEuler","text":"ForwardEuler(step_size::Float64) <: ExplicitRungeKuttaScheme\n\nDefines an Euler integration scheme to be used in integrate_time.\n\nArguments\n\nstep_size::Float64: the step size of the integration scheme.\n\n\n\n\n\n","category":"function"},{"location":"time_integration/#DiscretisedFluidQueues.Heuns","page":"Time Integration","title":"DiscretisedFluidQueues.Heuns","text":"Heuns(step_size::Float64) <: ExplicitRungeKuttaScheme\n\nDefines Heuns integration scheme to be used in integrate_time.\n\nArguments\n\nstep_size::Float64: the step size of the integration scheme.\n\n\n\n\n\n","category":"function"},{"location":"time_integration/#DiscretisedFluidQueues.StableRK3","page":"Time Integration","title":"DiscretisedFluidQueues.StableRK3","text":"StableRK3(step_size::Float64) <: ExplicitRungeKuttaScheme\n\nDefines a strong stability preserving Runge-Kutta integration scheme to be used in integrate_time.\n\nArguments\n\nstep_size::Float64: the step size of the integration scheme.\n\nHesthaven, J. S. & Warburton, T. (2007), Nodal discontinuous Galerkin methods: algorithms, analysis, and applications, Springer Science & Business Media. (Section 5.7)\n\n\n\n\n\n","category":"function"},{"location":"time_integration/#DiscretisedFluidQueues.StableRK4","page":"Time Integration","title":"DiscretisedFluidQueues.StableRK4","text":"StableRK4(step_size::Float64) = ExplicitRungeKuttaScheme(\n        step_size,\n        LinearAlgebra.LowerTriangular(_α),\n        LinearAlgebra.LowerTriangular(_β)\n    )\n\nDefines a strong stability preserving Runge-Kutta integration scheme to be used in integrate_time.\n\nArguments\n\nstep_size::Float64: the step size of the integration scheme.\n\nRaymond J. Spiteri and Steven J. Ruuth. A new class of optimal high-order strong-stability-preserving time discretization methods. SIAM J. Numer. Anal., 40(2):469-491, 2002.\n\nHesthaven, J. S. & Warburton, T. (2007), Nodal discontinuous Galerkin methods: algorithms, analysis, and applications, Springer Science & Business Media. (Section 5.7)\n\n\n\n\n\n","category":"function"},{"location":"time_integration/#DiscretisedFluidQueues.integrate_time","page":"Time Integration","title":"DiscretisedFluidQueues.integrate_time","text":"Given x0 and D apprximate x0 exp(Dy).\n\nintegrate_time(x0::Array{Float64,2}, D::AbstractArray{Float64,2},\n    y::Float64, scheme::ExplicitRungeKuttaScheme [; limiter])\n\nArguments\n\nx0: An initial vector\nD: A square matrix\ny: time to integrate up to\nh: ExplicitRungeKuttaScheme.\nlimiter: optional named argument spacifying the slope-limiter to used. The    limiter function will be applied at every stage and every time-step of the    ExplicitRungeKuttaScheme. \n\n\n\n\n\n","category":"function"}]
}
